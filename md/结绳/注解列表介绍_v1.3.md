【注解使用与介绍】
BY：白
时间：2022.08.25
版本：2->结绳4.0内测42
闲的无聊做的注解文档，如果有哪里有问题的话？请及时提出并修改
咱不是专业的，凑合着还是能看的
关于注解适用权限位置:
    类->方法->变量
        类级别可以写在任何地方
        方法级别写在方法及变量
        变量级别仅限变量使用到
        以下内容，如无特别表示，都用xx级别，表明适用位置
    使用时期
        由于编译器是按需编译的，多数的注解都是在用到 类/方法/变量 才会生效
        以下内容，如无特别表示，都是需要编译到才生效
    部分注解要配合来使用
        匹配文件 只有在 需求值类型 为 文件路径 时使用
        而 需求值类型 只有指定 常量类型 时才使用
关于使用参数：
    路径：
          "../xxx"表示在当前项目中的xxx
          "/storage/emulated/0/xxx"表示在手机存储目录中的xxx
【调试】
方法级别 中使用该注解，表示当前方法仅允许在运动调试时被使用到。
在正式打包项目时，该方法的使用将不会被打包进去
一般用于项目调试，如：调试输出(xxx) 该方法仅在调试时会打包到项目中，正式打包时不会被打包进去

【禁止调用】
方法级别 中使用该注解， 在任意处都不得调用该方法

【禁止继承】
类级别 中使用该注解， 在任意处都不得继承该类
（有BUG？？？）
【隐藏】
方法级别 中使用该注解，表示当前方法为 私有 (private)
将 方法级别 的访问权限设置 为 私有，这意味着，只能在当前的类使用
一般用于 写类库 时不需要被人外部所使用的 方法/变量 
其他地方无法调用到
 
[该注解一般用于写类库]
【属性需求】
仅限 定义事件 中使用到该注解，用于处理使用该事件，需要执行的前置方法
	使用环境：使用到事件需要先直行的方法
	用法：属性需求.方法名称(参数)

【运算符重载】
仅限 方法 中使用该注解，表示该方法会重载运算符，以更加客观的方式来使用这个方法
支持重载的符号有：= ? + - * / % == != < > <= >= [] []=
	结绳中文系列项目运算符"="重载规则变更：
		对于赋值语句，若赋值对象所在类重载了"="，
		赋值语句也会使用重载"="方法
如：
  类 xxx类型
    @运算符重载
    方法 +(参数:xxx类型) : xxx类型
        ....代码
        返回 参数
    结束 方法
    @运算符重载
    方法 -(参数:xxx类型) : xxx类型
        ....代码
        返回 参数
    结束 方法
    @运算符重载
    方法 [](参数:文本) : xxx类型
        ....代码
        返回 参数
    结束 方法
  结束 类
    使用：
        变量 xxx : xxx类型
        变量 xx : xxx类型
         xxx = xxx+xx
         xxx = xxx-xx
         xxx = xxx["x"]
【外部Java文件】
类级别 中使用该注解， 在打包的时候加入一个外部的java文件
在打包时，除非有添加到该注解，否则都不会加载其他的java文件
该注解需要一个参数（"路径"）
【全局基础类】
用于指定全局所有类的父类
一般人用不到滴
【主题配置】
仅限 主题资源 类型 使用该注解，设置该变量的主题资源配置
该注解需要一个后缀文本以及一个参数
目前，已拥有以下配置参数
  @主题配置.主题类型(主题类型.MD主题)
  @主题配置.主色调("#2196f3")
  @主题配置.强色调"#ffffffff")


【全局主题】
在任意位置可用，无论类方法变量是否被打包，都必定会使用到该注解，
用于设置整个软件的主题，
该注解需要一个参数(主题的名称)
【窗口主题】
应该仅限于继承 窗口 的类使用该注解，设置当前窗口的主题，
该注解需要一个参数(主题的名称)
【后缀代码】
仅限 类/方法 中使用该注解， 用于给代码附加后缀，一般用于抛异常，接入，接口，等java关键词使用
该注解需要一个参数（"往后面添加的代码"）
如：
    @后缀代码("extends a")
    类 测试
      @后缀代码("throws IOException")
      方法 测试()
      结束 方法
    结束 类
      
      打包转换为
      
      public 测试 extends a {
          public void 测试() throws IOException{}
      }
      

【前缀代码】
与后缀代码差不多，区别在于前缀是在前面附加的内容，而后缀是在后面附加的内容
前缀代码锁插入的代码应该位于权限修饰符前面
该注解需要一个参数（"往前面添加的代码"）
如：
    @前缀代码("abstract")
    类 测试
	  @前缀代码("private")
      方法 测试() 
      结束 方法
    结束 类
      
      打包转换为
      
      abstract public 测试 {
          public private final void 测试{}
      }
      
  PS:该代码会报错，毕竟我也不知道该怎么写好了
【嵌入式代码】
仅限 方法 中使用该注解，在打包的时候使用到该方法的地方嵌这个方法里面的内容
如：
    类 测试
	  @嵌入式代码
	  方法 测试(a : 文本)
		调试输出(a)
	  结束 方法
	  
	  @嵌入式代码
	  方法 测试0(a : 文本) : 文本
		调试输出(a)
		返回 a+"测试"
	  结束 方法
	  
	    @嵌入式代码
	  方法 测试1(b : 变体形)
		@code
		#b
		@end
	  结束 方法
    结束 类
    
    使用：
        变量 a : 文本
        测试.测试(a)
        a = 测试.测试0(a)
        测试.测试.1(
            调试输出2(a)
        )
        
        
        打包转为java时大概内容应为：
        
        String a = "";
        调试输出(a);
        调试输出(a);
        a = a+"测试";
        调试输出2(a);
    
    打包的时候将不是该方法，而是直接替换成相应的代码
    
    
【国际化】
仅限 文本资源 类型 中使用该注解
用于一个资源对应多种国家语言，实现国际化标准
该注解需要一个后缀文本(国家/地区代码)以及一个参数(文本)
如：
    @国际化.en_SU("U.S.A")
    变量 测试 : 文本资源 = "中国"
    
    在使用时，美国用户会显示U.S.A，其他用户会显示中国(默认文字)
【布局配置】
这个一般使用布局生成器一键生成
【禁止创建对象】
仅限 类 中使用该注解，不允许当前类被创建对象
	创建对象必须使用以下方式
	变量 xx对象 : xx类型?
	表示创建参考类型
	参考类型不会自动创建对象，需要手动创建对象
	变量 xx对象 : xx类型? = 新建对象(xx类型)
【外部依赖库】
在 类级别 中使用该注解，导入一个外部的依赖库，如jar,arr,包
参数中填写一个包的完整路径，表示添加一个包
参数中填写完整路径文件夹，表示添加该文件夹中所有包
该注解需要一个参数(路径)

【外部动态库】
在 类级别 中使用该注解，添加APK native lib库
参数中填写一个包的完整路径，表示添加一个库
参数中填写完整路径文件夹，表示添加该文件夹中所有库
该注解需要一个参数(路径)

【虚拟事件】
仅限 方法 使用该注解，将该方法当做事件使用
与3.0的定义事件相似
【输出名】
在 类级别 中使用该注解
默认的类型名称，输出规则rn_随机数
使用到该注解的话，将会指定 类/方法/变量 输出的名称
【指代类】
仅限 类 中使用该注解，让该类代表另一个类，
一般用于java类的封装，当他使用起来相当于一个工具类
需要注意的是：
在 @code 使用到该类，需要注意以下内容
类型声名只能用指代类的类型， 不能用当前类的类型
指代类中声明的是方法在使用需要多传一个参数（参第一个参数就是当前类型的对象参数）
#this代表指代类的对象
如若方法用到静态注解：#<类型.方法>(xxx)
如：
    @指代类("xx.xx.xxclass")
    类 类型
      方法 方法1(内容 : 文本): 文本
        code return #内容+#this.toString();
      结束 方法
      @静态
      方法 方法2(内容 : 文本) : 文本
        code return #内容;
      结束 方法
    结束 类
    
    //其他类中使用
    
    类 主
		@强制输出
      方法 测试()
          变量 类型1 : 类型
          变量 内容 : 文本 = "测试内容："
          类型1.方法1(内容)
          @code
            #<类型.方法1>(#类型1,#内容);
            #<类型.方法2>(#内容);	
          @end
      结束 方法
    结束 类
该注解需要一个参数("类")
【全局应用】
仅限于继承 安卓应用 类型 的 类 使用该注解，将该类设置为默认的安卓应用
【强制输出】
在任意位置可用，无论类方法变量是否被打包，都必定会使用到该注解，
当该注解应用到 类 时，将强制输出该类所有成员
无论是否有使用到，多将强制被打包

【导入Java】
在 类级别 中使用该注解，导入一个java包
【虚拟方法】
仅限 方法 中使用该注解，将当前方法设置为虚拟方法
	
【附加资源】
在 类级别 中使用该注解，添加assets资源文件
参数中填写完整路径文件，表示添加一个文件
参数中填写完整路径文件夹，表示添加该文件夹,含文件夹内所有文件
在使用资源时所添加的文件存于一级路径
如：

@附加资源("../assets/")
@附加资源("../资源/a.txt")
方法 测试()
	//assets中假设包含两个文件b,c.txt以及两个文件夹a,b内同样包含三个文件a,b,c.txt
	文件操作.读取文件("a.txt")
	文件操作.读取文件("b.txt")
	文件操作.读取文件("c.txt")
	文件操作.读取文件("a/b.txt")
	文件操作.读取文件("a/a.txt")
	文件操作.读取文件("a/c.txt")
结束 方法
该注解需要一个参数(路径)

【安卓资源】
在 类级别 中使用该注解，导入项目res文件资源
该注解有一个可选参数
    @安卓资源
        传入一个res文件夹路径，有重名也不会覆盖，会直接合并两个文件
    @安卓资源.布局
    @安卓资源.动画
    @安卓资源.图片
    @安卓资源.XML
        将一个指定类型资源文件打包到apk，如果有重名的会直接覆盖
        
    使用到资源的方法跟java一样，R.xxx.xxx
【静态】
在 类级别 中使用该注解，将声明的 类/方法/类变量 允许在其他的类中无需声明类对象直接使用方法/变量
【附加可变清单】

【附加清单】
在 类级别 中使用到该注解，配置清单文件的附加参数
这个注解的东西有一点点多
附加清单支持：占位符
applicationId -> APK包名

@附加清单：
用于在清单文件中附加四大组件，只有注解所指定的成员被使用才会生效

@附加清单.文件关联:


@附加清单.URI关联:


@附加清单.全局属性：
用于在清单文件中为application节点附加属性

@附加清单.属性：
用于为当前调用栈中最顶端的四大组件附加属性

@附加清单.配置：
用于为当前调用栈中最顶端的四大组件附加配置项


@附加清单("四大组件...")
PS：建议用常文本来表示[[]]
@附加清单([[
<activity name="com.my.ABC"
  label="aaa">
</activity>
]])
@附加清单.组件属性(硬件加速)
@附加清单.组件配置("文件关联")
【附加权限】
在 类级别 中使用到该注解，添加一个权限

该注解需要一个参数（"安卓权限"）
【全局类】
仅限 类 中使用到该注解，将这个类设置为全局可用的类
不需要写类名即可直接使用方法

【外部基础类】
【值输出规则】

【软件配置】

    @软件配置.软件图标(路径)
    @软件配置.版本名称(名称)
    @软件配置.版本号(版本号)
    @软件配置.版本名称(名称)
    @软件配置.最低安卓版本(版本)
    @软件配置.目标安卓版本(版本)

PS:需要编译器插件注册值输出规则

【编译时处理参数】
仅限 方法 中使用该注解，在编译处理的参数，一般的开发者无需理会
	需要配合其他需要参数的注解使用，但是不经意经常使
	仅部分注解有效
		@附加清单
		@软件配置
如：
    @编译时处理参数
@附加清单([[android:allowBackup="${参数1}"]])
方法 参数(参数1 : 逻辑型)
	//这里的代码是正常执行方法的代码可以留空
结束 方法
使用：
参数(真)
参数
PS:需要编译器插件注册值输出规则

【匹配文件】
仅限 类 中使用该注解，需要配合使用 (需求值类型 为 文件路径)
指定该类的变量的值必须为指定的文件类型
该注解需要一个参数("匹配规则")
PS:需要编译器插件注册值输出规则

【常量类型】
仅限 类 中使用该注解，使用到该类，里面只能有变量，不能有方法
变量全部为常量
该注解需要一个参数(类型)
PS:注意了，不要加双引号
PS:需要编译器插件注册值输出规则

【需求值类型】
仅限 类 中使用该注解，需要配合使用(常量类型)
指定该类的变量的值必须为指定的类型
该注解需要一个参数(类型)
PS:注意了，不要加双引号
PS:需要编译器插件注册值输出规则