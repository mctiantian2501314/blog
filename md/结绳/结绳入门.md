# 一份文档入门结绳
> 编辑作者:RedemptionCQFC
> 编辑时间:2023年7月19号
> 结绳版本:tiecode4.1.7
> 注:建议使用MD解析器打开本文档
### 1.结绳简介
>上古结绳而治，后世圣人易之以书契。
##### 1.1.结绳是什么？结绳中文是什么？
##### 1.2.结绳是谁开发的？
##### 1.3.结绳的官方网站在哪？官方群呢？
##### 1.4.在官方群时，我应该注意什么？
### 2.结绳使用
>适应结绳开发环境，熟悉各种关于结绳的操作，以及它们的后缀标识符。
##### 2.1.创建工程
##### 2.2.导入工程
##### 2.3.安装插件
##### 2.4.管理文件
##### 2.5.安装绳包
##### 2.6.部署绳包
##### 2.7.顶项操作
##### 2.8.右上菜单
##### 2.9.编辑操作
##### 2.10.项目操作
##### 2.11.小工具
##### 2.12.插件管理
##### 2.13.结绳安卓项目管理器
##### 2.14.长按菜单
### 3.结绳语法
>语法往往都是编程语言的基础，开发必须掌握它的语法。
##### 3.1.变量与常量
##### 3.2.如果语句
##### 3.3.假如语句
##### 3.4.循环语句
##### 3.5.方法
##### 3.6.事件
##### 3.7.类
##### 3.8.属性读与属性写
##### 3.9.定义事件
### 4.结绳注解
>注解用于补充说明一个成员，*为罕见的注解，**为原生封装才用的注解，***为一般人用不了的注解，同时注解后面带三个点的表示该注解有很多子注解。
##### 4.1.隐藏
##### 4.2.静态
##### 4.3.调试
##### 4.4.*禁止调用
##### 4.5.禁止继承
##### 4.6.*废弃使用(文本)
##### 4.7.属性需求.方法名(值)
##### 4.8.运算符重载
##### 4.9外部Java文件(文本)
##### 4.10.***全局基础类
##### 4.11.主题配置...
##### 4.12.全局主题(文本)
##### 4.13.窗口主题(文本)
##### 4.14.**后缀代码(文本)
##### 4.15.**前缀代码(文本)
##### 4.16.**嵌入式代码
##### 4.17.*国际化
##### 4.18.布局配置(文本)
##### 4.19.禁止创建对象
##### 4.20.**外部依赖库(文本)
##### 4.21.**外部动态库(文本)
##### 4.22.虚拟事件
##### 4.23.*输出名(文本)
##### 4.24.**指代类(文本)
##### 4.25.全局应用
##### 4.26.强制输出
##### 4.27.**导入Java(文本)
##### 4.28.虚拟方法
##### 4.29.附加资源(文本)
##### 4.30.*安卓资源...
##### 4.31.*附加清单...
##### 4.32.*编译时处理参数
##### 4.33.*附加可变清单...
##### 4.34.附加权限(文本)
##### 4.35.全局类
##### 4.36.异步方法
##### 4.37.***需求值类型(类)
##### 4.38.***常量类型(类)
##### 4.39.***匹配文件(文本)
##### 4.40.***值输出规则(文本)
##### 4.41.**外部基础类(文本)
##### 4.42.*Native构建
##### 4.43.*软件配置...
##### 4.44.[Linux]外部源文件(文本)
##### 4.45.[Linux]引入头文件(文本)
### 5.结绳特性
>不是语法范畴之内，但是还是要讲一下。
##### 5.1.基本类型
##### 5.2.运算符
##### 5.3.显式转换
##### 5.4.数组
##### 5.5.本对象与父对象
##### 5.6.订阅事件
##### 5.7.包
##### 5.8.创建
### 6.专有名词名单
>解释一下平常可能遇到到一些名词。
##### 6.1.空对象/空(null)
##### 6.2.面向过程编程(ProceduralProgramming)
##### 6.3.面向对象编程(object-oriented programming/OOP)
##### 6.4.面向函数编程(FunctionalProgramming)
##### 6.5.安卓组件(AndroidComponents)
##### 6.6.堆栈(stack)
##### 6.7.线程(thread)
##### 6.8.指针(pointer)
### 7.常见异常分析
>注意哦，黄色的是警告，红色的才是异常，同时异常和错误不是一个意思，异常是说遇到的逻辑不在正常范围内，而错误是指严重的异常，错误一般不能被俘获。
##### 7.1.空指针异常(NullPointerException)
##### 7.2.索引越界异常(IndexOutOfBoundsException)
##### 7.3.类型转换异常(ClassCastException)
### 8.常见问题解决
>这里是常见的一些问题，你可以看看有没有你想问的。
##### 8.1.安卓环境获取问题
##### 8.2.全局共享变量问题
##### 8.3.单例获取对象问题
##### 8.4.列表类型项目问题
##### 8.5.资源文件读写问题
##### 8.6.新主线程切换问题
##### 8.7.容错俘获处理问题
##### 8.8.网络工具使用问题
### 9.通用数据格式
>这里是编程界通用的交流格式。
##### 9.1.JSON
##### 9.2.XML
##### 9.3.MD
### 10.可视化布局
>应用不是控制台，所以需要可视化布局
##### 10.1.自适应布局
##### 10.2.线性布局
##### 10.3.相对布局
##### 10.4.宫格布局
##### 10.5.纵横滚动布局
##### 10.6.卡片布局
##### 10.7.分页布局
##### 10.8.侧滑布局
##### 10.9.单选框布局
##### 10.10.组件容器
##### 10.11.提示框
##### 10.12.对话框
##### 10.13.悬浮窗
## 1.结绳简介
### 1.1.结绳是什么？结绳中文是什么？
**结绳**是一款编程软件，你可以在**结绳**里面使用**结绳中文**(**TieCode**)**编程语言**开发程序，也就是说，**结绳**是一个**应用软件**，而**结绳中文**是一个**编程语言**。
### 1.2.结绳是谁开发的？
**结绳**由**结绳团队**开发，**结绳团队**于**2019**年成立，团队由最初的4人到6人再到18人，在**结绳**4.0.0版本以前，**结绳中文**的英文名叫做**S5droid**，4.0.0以后改为**TieCode**，同时，**结绳开发团队**更名为**结绳项目团队**。
### 1.3.结绳的官方网站在哪？官方群呢？
**结绳**的官方网站是==http://www.tiecode.cn/==，结绳的官方群有两个，一个为大群(编程技术讨论群)==938828067==，一个为小群(编程自由讨论群)==1074469442==。
### 1.4.在官方群时，我应该注意什么？
在大群时，请尽量不要讨论其他编程语言，以及其他非编程有关话题；小群可以讨论其他话题与程语言。并且，低于结绳4.0.0版本的问题不再接受，同时禁止交谈外挂/病毒/锁机等**禁忌工程**，以及禁止推送广告链接等。QQ官方和国家明文规定的非法行为也是不被允许的。
## 2.结绳使用
### 2.1.创建工程
打开结绳，右下角红色圆形+号按钮，点击即可创建工程，下面是对工程的介绍。
[工程类型]表示即将创建的工程类型。
[工程模板]这里是结绳为你预先准备的工程模板。
[工程名称]工程在结绳中显示的名称。
[软件名称]打包后安装到你的手机上的应用名称。
[软件包名]应用软件的身份证，至少含有一个小数点，且没有特殊字符，如果输入中文，结绳会自动把中文转为拼音。
### 2.2.导入工程
打开结绳，左下角有四个红色按钮，点最左边的按钮，选择**导入工程**，然后再选择工程备份路径即可，一般来说，结绳的工程备份文件以tsp后缀。
### 2.3.安装插件
打开结绳，左下角有四个红色按钮，点最左边的按钮，选择**安装插件**，然后再选择插件文件路径即可，一般来说，结绳的插件文件以tpk后缀。
### 2.4.管理文件
打开结绳，打开你的工程，左上方有个**三**，点这个**三**，就可以打开工程文件管理界面了，长按文件夹夹或文件即可操作。
### 2.5.安装绳包
绳包，全称结绳扩展包，用于提供对工程的额外支持。打开结绳，打开你的工程，右上角有三个点，点开它，选择**安装绳包**，然后再选择绳包文件路径即可，一般来说，结绳的绳包文件以tlb后缀。
### 2.6.部署绳包
打开结绳，打开你的工程，左上方有个**三**，点这个**三**，就可以打开工程文件管理界面了，然后长按**绳包**文件夹，选择**管理绳包**，然后勾选你想要部署的绳包即可。
### 2.7.顶项操作
打开结绳，打开你的工程，上面有几个小图标，现在介绍一下它们的作用。
[铅笔/眼睛-读写切换]图标为铅笔时，表示当前为写模式，图标为眼睛时，表示当前为读模式，读模式无法编辑代码
[三角形-运行按钮]单击即可编译打包你的工程，长按可选择打包类型，默认为调试运行。
[左箭头-撤回]表示撤回你刚才的操作
[右箭头-还原]表示还原你刚才的操作
### 2.8.右上菜单
打开结绳，打开你的工程，右上角有三个点，点开它，这里有几个菜单，简单介绍一下。
[保存]保存当前工程代码
[日志]打开日志页
[git]打开git页
[安装绳包]见2.5
### 2.9.编辑操作
打开结绳，打开你的工程，右上角有三个点，点开它，再点开**编辑操作**，简单介绍一下。
[粘贴]将你的剪切板的内容粘贴到你光标的位置里。
[查找]打开查找功能，可以在当前代码里查找关键词。
[替换]和查找差不多，不过多了个替换关键词的功能。
[复制一行]复制光标当前行，然后粘贴到下一行。
[删除一行]删除本行代码。
[对齐代码]缩进难看时可以点一下，自动对齐缩进。
### 2.10.项目操作
打开结绳，打开你的工程，右上角有三个点，点开它，再点开**项目操作**，简单介绍一下。
[备份项目]会备份当前项目到结绳的backups目录里。
[分享源码]把项目分享给应用。
[修改信息]修改工程的信息
[清理缓存]结绳编译时会留下缓存，可以清理掉它来减少存储空间。
[正式打包]去除所有调试类，正式打包为一个独立的安装包。
[制作绳包]将当前工程打包为绳包，但是初始代码.t不会打包，绳包文件位于工程的build/lib里面。
[部署到设计器]没有用，一般用来免打包编译。
### 2.11.小工具
结绳自带的小工具有三个，现在一一来介绍它们。
[颜色选择]打开会弹出一个颜色选择框，可以在色图上选中一个颜色点，下方的条用于控制透明度，点击复制按钮即可把该颜色的RGB格式(16进制)复制到你的剪切板中。
[路径浏览]打开后出现一个文件预览框，点击文件夹会进入该文件夹内，点击上面的上一级..即可回到上一个文件夹，点击文件即可复制该文件路径，点击下面的复制按钮即可复制当前文件夹的路径。
[背景图制作]打开后弹出一个界面，用于制作XML背景图，可以添加状态来确定XML背景图在不同的状态下显示的不同图片，圆角度数表示图片的圆角度数，注意要带单位，比如DP，填充颜色和边框颜色懂得都懂，不细说，边框宽度和圆角度数一样，也要带一个单位。
### 2.12.插件管理
打开结绳，左下角有四个红色圆形按钮，从左到右第三个按钮就是插件管理界面，你可以在这里管理你安装的创建。
打开插件管理界面后，你可以看到一个个插件卡片，插件卡片右上角有三个点，分别是设置、停用、卸载。
[设置]进入插件的设置界面，可以管理插件的行为参数。
[停用]禁止插件运行，但是你可以再次让插件启用运行。
[卸载]插件会彻底跟你说拜拜。
### 3.13.结绳安卓项目管理器
实际上，它是一个结绳自带的插件，但是为什么结绳自带4个插件，然而单独拿它出来讲，我先说一下为什么。
Java控制台项目管理器和标准安卓项目管理器已迁移到书契，结绳在以后会彻底去除这两个项目，所以不讲。
Windows项目还没有出，而Linux项目不常用，同时它的平台语言实际上是C++而不是Java，所以不讲。
OK，进入主题，结绳安卓项目管理器的设置分别如下：
[使用D8编译器]开启后，编译结绳安卓工程会使用D8编译器，关闭则使用DX编译器，D8编译器的各方面秒杀DX编译器，所以最好使用D8编译器，但是安卓8以下安卓版本只能使用DX编译器。
[编译优化]会对你的代码进行优化，从而执行更快，建议开启，包括但不限于去除空语句，去除必定不执行分支语句等。
[安装NDK]NDK是安卓开发中调用底层代码(C/C++)的工具包，允许结绳可以编译底层语言，未安装NDK将无法使用注解@Native构建。
[使用V2&V3签名]打包apk并签名时会使用V2和V3签名，关闭则只使用V1签名，V1安全性较低，容易被篡改，所以建议开启。
[创建签名证书]可以创建一份签名文件，文件类型分别有JKS和PKCS12和X509。
JKS一般用来加密apk文件，PKCS12一般用来网络传输加密，X509一般用来普通文件加密，一般创建证书使用JKS。
剩下的证书信息就不多讲了，因为结绳已经内置的简单的解释，按需填写即可。
[签名证书]打包apk时会用到的签名证书，找到证书文件然后选择即可。
[App日志过滤]新手建议开启，开启后会过滤掉不重要的日志信息，一般是堆栈信息。
[自定义符号栏]自定义编辑结绳安卓工程时的快捷符号栏，不多解释。
### 2.14.长按菜单
在结绳安卓工程的编辑过程中可以在代码页长按，会弹出一个长按菜单，里面有7项内容，但是实际上只有4项内容是开启的。
[设计布局]在窗口或组件容器里面可以设计布局，使用TLY编辑会将布局变为TLY格式，可视化布局设计会进入一个界面，在此可以编辑布局。
[添加事件/方法]在类里添加会弹出一串列表，里面就是类的虚拟事件以及虚拟方法，点击即可添加，当然，你也可以为变量添加它的事件。
[重命名]在类名上重命名会修改类的名字，同时所有用到该类名的地方也会一起改，也可以修改方法名和变量名。
[转到定义]在类名/方法名/变量名上使用会转到声明该类/方法/变量的地方。
## 3.结绳语法
### 3.1.变量与常量
**变量**是用来存储**数据**的一种**标识符**。可以将其看作是一个**容器**，用来存储各种各样的**值**。**变量**有不同的**类型**，例如**整数**、**小数**、**文本**等等。在程序执行过程中，**变量**的值可以被**更改**。**常量**是在程序中固定不变的**值**。与**变量**不同，**常量**在**定义**之后就无法修改。
变量的声明格式为:
```
变量 变量名称 为 类型
```
>有时候为了方便，可以把**为**替换为一个**冒号**(**:**)

可以在**声明变量**的同时为**变量赋值**:
```
变量 变量名称 为 类型 = 值
```
结绳会自动为**引用类型**的变量创建对象，但是如果类型后面带有?，结绳就不会自动创建对象，即该变量为空:
```
变量 变量名称 为 引用类型?
```
常量的声明和变量差不多:
```
常量 常量名称 为 类型 = 值
```
### 3.2.如果语句
如果语句用于根据某个条件是否为真来决定程序的执行路径。可以将其理解为一种选择结构。根据条件的不同结果，程序会选择不同的路径执行。
如果语句分为3种，分别为；
**(普通)如果语句**:
```
如果 逻辑表达式 则
    //当逻辑表达式为真时执行
结束 如果
```
**如果-否则语句**:
```
如果 逻辑表达式 则
    //当逻辑表达式为真时执行
否则
    //当逻辑表达式为假时执行
结束 如果
```
**如果-否则-否则语句**:
```
如果 逻辑表达式1 则
    //当逻辑表达式1为真时执行
否则 逻辑表达式2
    /*
    当逻辑表达式1为假
    但是逻辑表达式2为真时执行
    */
...
否则
   //所有逻辑表达式均为假时执行
结束 如果
```
### 3.3.假如语句
假如语句是一种选择结构，用于根据一个变量的不同值来选择不同的执行路径，可以将其理解为一种多重选择的语句。
假如语句分为2种，分别为；
**(普通)假如语句**:
```
假如 变量名
    是 常量情景1
       //命中情景1时执行
    是 常量情景2
       //命中情景2时执行
    是 常量情景3
       //命中情景3时执行
结束 假如
```
**假如-否则语句**:
```
假如 变量名
    是 常量情景1
       //命中情景1时执行
    是 常量情景2
       //命中情景2时执行
    是 常量情景3
       //命中情景3时执行
    否则
       //没有命中情景时执行
结束 假如
```
### 3.4.循环语句
**循环语句**的作用是重复执行一段**代码块**，直到达到某个**条件**为止。它可以帮助程序员节省时间和精力，避免重复编写相同的代码。
**循环语句**的主要目的是处理需要重复执行的**任务**，例如对**数组**中的每个**元素**进行操作，或在遇到满足一定条件的情况下执行特定的代码。通过使用循环语句，可以在不同的情况下重复执行相同的代码，而不需要手动**复制**和**粘贴**代码块。
**循环语句**分为三种；
**判断循环语句**:
```
循环(逻辑表达式)
    /*
    循环代码块
    每执行完毕一次
    就判断逻辑表达式
    如果为真则继续循环
    如果为假则停止循环
    */
结束 循环
```
**变量循环语句**:
```
循环(变量名,初始值,终止值,步值)
    /*
    循环代码块
    变量会首先赋值为初始值
    当初始值超过终止值时
    停止循环
    步值代表每次循环增进的值
    */
结束 循环
```
**遍历循环语句**:
```
循环(集合或数组->元素)
    /*
    循环代码块
    每一次循环都会
    把集合或数组的元素
    遍历到一个变量上
    */
结束 循环
循环(哈希表->键,值)
    /*
    循环代码块
    每一次循环都会
    把哈希表的键值
    遍历到两个变量上
    */
结束 循环
```
同时，为了更好的操控循环语句，还有两个特殊的语句，**退出循环**表示终止当前循环，**跳过循环**表示跳过当前次循环，到下一次循环。
```
循环()
    //循环代码块
    跳过循环
结束 循环
```
```
循环()
    //循环代码块
    退出循环
结束 循环
```
### 3.5.方法
**方法**指的是一段可重复使用的**代码块**，它接收输入**参数**、执行特定的**任务**，并返回一个**返回值**。
**方法**声明格式为:
```
方法 方法名()
    //方法体
结束 方法
```
带**返回值**是这样的:
```
方法 方法名() 为 返回类型
    //方法体
    返回 返回值
结束 方法
```
带**参数**是这样的:
>方法可以有多个参数，比如(参数1 为 类型,参数2 为 类型)
```
方法 方法名(参数1 为 类型)
    //方法体
结束 方法
```
调用**方法**的**格式**是这样的:
```
方法名(参数1,参数2)
```
### 3.6.事件
**事件**与**方法**差不多，但是事件一般用来**被动**执行，而方法用来**主动**执行。
**事件**的声明格式为:
```
事件 监听对象:监听事件()
    //触发事件时执行
结束 事件
```
**事件**和**方法**一样，某些**事件**会带有**参数**和**返回值**。
```
事件 监听对象:监听事件(参数 为 类型)
结束 事件
事件 监听对象:监听事件() 为 类型
结束 事件
```
### 3.7.类
**类**是一种**数据结构**，用于封装**属性**与**行为**。**类**可以被视为**对象**的蓝图或模板，描述了**对象**的特性和行为。**类**是**面向对象设计**的基本概念之一。
**类**由**属性**和**行为**组成。**属性**是**类**的**变量**，描述了**对象**的状态；**方法**定义了**类**的**行为**，描述了**对象**的**行为**和**操作**。
**类**可以通过**实例化**创建**对象**，**对象**是**类**的一个**实例**。**对象**具有**类**定义的**属性**和**行为**。每个**对象**都可以独立地**访问**和**修改**其**属性**，调用其方法。
类的声明格式分为2种；
**隐式继承**:
>隐式继承会自动指定父类，父类一般为当前平台的@全局基础类
```
类 类名
    //类体
结束 类
```
**显式继承**:
```
类 类名 : 父类名
    //类体
结束 类
```
以上的声明格式均为声明**普通类**，在**结绳中文**中还有一种特殊的类声明格式：**模板类**。
**模板类**允许在编写代码时使用一种通用**类型**，而不是具体的**类型**。**模板类**提供了代码的灵活性和可重用性，可以在不同的数据**类型**上使用相同的代码逻辑。
**模板类**仅提供一个**类模板**，而不能直接使用，需要一个类来继承**模板类**并指定其**模板类型**，我们称这个类叫做**实现类**。
>模板类的子类也可以是模板类

**模板类的声明格式为**:
```
类 模板类名<模板类型1>
    //模板类体
结束 类
```
**实现类的声明格式为**:
>一般来说，实现类体是空的
```
类 实现类名 : 模板类名<指定类型>
结束 类
```
### 3.8.属性读与属性写
**属性读**与**属性写**是两种特殊的**方法**，它们的作用更加纯粹，只是用来体现**读取**和**写入**两个动作，并且它们的声明格式十分严格。
**属性读的声明格式为**:
>属性读没有参数，且必须有返回值
```
属性读 名称() 为 类型
    //方法体
结束 属性
```
**属性写的声明格式为**:
>属性写有且只有一个参数，且没有返回值
```
属性写 名称(参数 为 类型)
    //方法体
结束 属性
```
### 3.9.定义事件
**定义事件**用来为类实例定义一个**事件监听器**，而**事件监听器**可以通过**事件**语句监听。
```
定义事件 事件名()
```
当然，**事件**可以有**参数**与**返回值**
```
定义事件 事件名(参数 为 类型) 为 类型
```
这时，你可以把**定义事件**当做一个**方法**调用，调用**定义事件**就代表触发这个**事件**。
## 4.结绳注解
### 4.1.隐藏
用于指定**成员**为**私有的**，即在**原生**中附加**private**修饰符，在**类**外无法直接**访问**该**成员**。
### 4.2.静态
用于指定**成员**为**静态的**，**静态成员**属于**类**本身而不是通过**类实例化**出来的**对象**，**静态成员**以"类名.成员名"调用。
### 4.3.调试
用于指定该**方法**为调试**方法**，在**正式打包**后会去除该**方法**。
### 4.4.禁止调用
用于指定该**方法**在任何地点都不得调用。
### 4.5.废弃使用(文本)
用于指定该**方法**已经过时，废弃了，如果调用就会在日志输出警告文本。
### 4.6.禁止继承
指定一个类被禁止继承，即此类不能有子类，不能成为任何类的父类。
### 4.7.属性需求.方法名(值)
只能用在定义事件上面，后面XXX表示一个方法名，用于设定先触发的方法。
### 4.8.运算符重载
指定一个方法重载了运算符，可重载的运算符有= ? + - * / % == != < > <= >= [] []=，使用运算符时会调用运算符重载的方法来处理。
### 4.9.外部Java文件(文本)
在类上标注，打包时附加该Java文件进行编译，注意文件是java后缀。
### 4.10.全局基础类
设定该类为隐式继承的父类，一般来说，此类被**对象**类占用，一般人用不了。
### 4.11.主题配置
设置该变量的主题配置，同时该变量必须是**主题资源**类，其下有多个副分支，比如@**主题配置.主题类型()**。
### 4.12.全局主题(文本)
设置整个应用的主题，参数必须是一个变量名，且变量类型必须是**主题资源**。
### 4.13.窗口主题(文本)
与**全局主题**相反，窗口主题是设置本窗口的主题。
### 4.14.后缀代码(文本)
在类或者方法后面添加一段代码，一般是原生用途，普通使用结绳中文用不到，比如在类后面添加**implements a**。
### 4.15.前缀代码(文本)
和后缀代码差不多，不过是在前面添加，一般用来加修饰符，比如前缀**abstract**
### 4.16.嵌入式代码
指定该方法为嵌入式代码，该方法在打包时会去掉，并且把使用用到该方法的地方嵌入进去方法的代码，同时方法参数允许使用**变体型**，**变体型**表示你填什么都可以，甚至是**类名**，注：嵌入式代码内必须全是code代码，否则报错。
### 4.17.国际化
指定该变量在相应的语言环境下的内容，并且该变量的类型必须是**文本资源**，国际化有几个子注解，比如@**国际化.en.SU(文本)**
### 4.18.布局配置(文本)
此注解由布局设计器自动生成，请勿随意删除修改。
### 4.19.禁止创建对象
表示该类不能由结绳自动创建对象，需要手动创建或者不需要创建。
### 4.20.外部依赖库(文本)
参数为路径，表示导入一个jar/aar包，打包时会带上它。
### 4.21.外部动态库(文本)
和外部依赖库差不多，不过是导入so包。
### 4.22.虚拟事件
表示该方法为虚拟事件，该方法禁止有任何代码，并且不得拥有返回值，此类的子类可以监听自己继承而来的的虚拟事件。
### 4.23.输出名(文本)
结绳会自动混淆类名/方法名/变量名，可以使用该注解指定最终输出名。
### 4.24.指代类(文本)
指定一个类是指代一个原生类的，参数为**完整类名**，即被指代的原生类。
### 4.25.全局应用
指定该类为本应用的安卓应用，此类必须继承**应用**类。
### 4.26.强制输出
无论是否用到该类/方法/变量，结绳都会为其编译。
### 4.27.导入Java(文本)
导入一个Java包类，一般用于原生封装开发，相当于**import xxx.xx**。
### 4.28.虚拟方法
设置该方法为虚拟方法，虚拟方法可以被子类覆写。
### 4.29.附加资源(文本)
附加一个资源文件，将其打包到安装包的assets文件夹里。
### 4.30.安卓资源
该注解有多个子注解，比如@**安卓资源.动画(文本)**，与附加资源不同的是，该注解会打包到res文件夹。
### 4.31.附加清单
该注解下有多个子注解，比如@**附加清单.属性(文本)**，用于为安卓清单附加内容。
### 4.32.编译时处理参数
表示注解可以引用方法的参数。
### 4.33.附加可变清单
和附加清单差不多，不过可以通过改变方法的参数来改变清单的内容。
### 4.34.附加权限(文本)
表示附加一个权限，参数为权限名。
### 4.35.全局类
表示该类的静态成员不需要通过**类名.成员名**引用，可以直接**成员名**。
### 4.36.异步方法
表示此方法为异步方法，异步方法必须有一个**等待过程**，可以使用**等待**关键词来声明**等待过程**，**等待 方法名()**，**方法名()**此时在新线程执行，执行完成后再执行**非等待部分**，**非等待部分**在主线程执行，注：异步方法不能有返回值。
### 4.37.需求值类型(类)
需求值类型表示当前类创建所需的值，参数为任意**基本类型**或**文件路径**或**颜色值**。
### 4.38.常量类型(类)
表示当前类实际上指代的基本类型，参数只能为基本类型。
### 4.39.匹配文件(文本)
该注解附加前需要先附加@**需求值类型(文件路径)**，该注解表示创建本类对象所需的文件格式，参数为正则表达式文本，不符合则报错。
### 4.40.值输出规则(文本)
用于指定本类对象的值输出路径，一般是安装包内资源路径。
### 4.41.外部基础类(文本)
表示该类继承原生类，参数为被继承的原生类的完整类名。
### 4.42.Native构建
表示该方法的代码会构建到外部动态库，而不是在dex文件中定义，如果你没有安装NDK，将无法使用该注解。
### 4.43.软件配置
用于指定软件的配置，该注解下有多个子注解，如@**软件配置.软件名称(文本)**
### 4.44.外部源文件(文本)
Linux工程专属注解，用于附加外部原生的.h/.cpp参与编译。
### 4.45.引入头文件(文本)
Linux工程专属注解，用于在当前文件引入其他文件。
## 5.结绳特性
### 5.1.基本类型
结绳的**基本类型**共有8个，它们分别是**整数**、**长整数**、**字节**、**小数**、**单精度小数**、**逻辑型**、**字符**，部分看起来是**基本类型**实际上是**引用类型**的有很多，比如**文本**。
### 5.2.运算符
运算符分为很多种，按操作数可分为**一元运算符**、**二元运算符**、**三元运算符**，按功能分为**数学运算符**、**逻辑运算符**、**赋值运算符**。
a + b(**二元数学运算符**,ab均为**加数**,返回**和**)
a - b(**二元数学运算符**,a为**被减数**,b为**减数**,返回**差**)
a / b(**二元数学运算符**,a为**被除数**,b为**除数**,返回**商**)
a * b(**二元数学运算符**,ab均为**乘数**,返回**积**)
a % b(**二元数学运算符**,a为**被除数**,b为**除数**,返回**余数**)
a == b(**二元逻辑运算符**,ab均为**值**,返回**是否相同**)
a != b(**二元逻辑运算符**,ab均为**值**,返回**是否不同**)
a < b(**二元逻辑运算符**,ab均为**数字**,返回**a是否小于b**)
a > b(**二元逻辑运算符**,ab均为**数字**,返回**a是否大于b**)
a <= b(**二元逻辑运算符**,ab均为**数字**,返回**a是否小于或等于b**)
a >= b(**二元逻辑运算符**,ab均为**数字**,返回**a是否大于或等于b**)a ? b(**二元逻辑运算符**,ab均为**文本**,返回**a是否包含b**)
a < b < c(**三元逻辑运算符**,abc均为**数字**,返回**a是否小于b并且b是否小于c**)
a > b > c(**三元逻辑运算符**,abc均为**数字**,返回**a是否大于b并且b是否大于c**)
a <= b <= c(**三元逻辑运算符**,abc均为**数字**,返回**a是否小于或等于b并且b是否小于或等于c**)
a => b => c(**三元逻辑运算符**,abc均为**数字**,返回**a是否大于或等于b并且b是否大于或等于c**)
++a(**一元赋值运算符**,a为**变量**,类型为**任意数学类型**，使a自己+1)
--a(**一元赋值运算符**,a为**变量**,类型为**任意数学类型**，使a自己-1)a = b(**二元赋值运算符**,a为**变量**,b为**值**，使a等于b)
a <=> b(**二元赋值运算符**,ab均为**变量**，使ab互换它们的值)
注:部分未在此处发现的运算符可能不是原生运算符，应该是运算符重载，请前往相应的运算符重载方法处查看。
### 5.3.显式转换
**基本类型**的**显式转换**与**引用类型**的**显式转换**是两套不同的规则。
结绳的**显式转换**语法是：
```
(值:欲转换类)
```
**[基本类型]**基本类型的显式转换可以让精度低的值安全转为精度高的值，精度高的值转换为精度低的值的时候有可能会损失精度。
**[引用类型]**引用类型的显式转换可以让子类对象安全转为父类对象，父类对象在转换为子类对象时可能会报错，只有父类对象本身是一个被转换的子类对象才能重新转换为子类对象。
### 5.4.数组
**数组**和**集合**类似，都是用于存储**对象**的，只不过**集合**的最大容量是自适应的，而**数组**的最大容量是固定的。
数组的声明格式为：
```
变量 数组名 为 元素类型[]
```
其中，**元素类型**代表**数组**的**元素**的**类型**，但是此时，这个**数组**为**空**，还没有赋值。
**数组**声明带赋值分为两种：
**[静态]**提前指定**数组**元素，根据元素数量自适应**数组**长度。
**[动态]**直接声明**数组**的长度，但是不会填充**元素**，即**元素**为**空**或为**基本类型默认值**。
```
变量 静态数组 为 元素类型[] = {
元素1,元素2,元素3}
变量 动态数组 为 元素类型[3]
```
**数组**有两个独特的**运算符**：
```
/*注:数组的索引以0开始*/
//通过[]下标访问数组的元素
数组名[0]
//通过[]=下标等于来为数组元素赋值
数组名[0]=114514
```
### 5.5.本对象与父对象
**本对象**和**父对象**是**结绳中文**里的两个关键词，**本对象**我们经常用到，所以先介绍它。
**本对象**只能在非静态环境中使用，比如下面的代码会报错：
```
@静态
方法 我是静态方法()
    本对象.弹出提示("a")
结束 方法
```
同时，**本对象**不能在初始化变量时使用，比如下面的代码。
```
变量 成员变量 为 类型 = 本对象
```
哎好好好，我在**静态环境**里面不用**本对象**得了吧，哎~，还是不行的，因为你使用自己的**方法**时实际上**隐式**的带一个**本对象**，只不过给省略了而已。
```
弹出提示("a")
//这两行代码是一样的
本对象.弹出提示("a")
```
讲这么多，这**本对象**究竟是什么意思呢？很简单，它指的就是当前这个**对象**，通俗来说就是**“我”**。
那**父对象**呢？**父对象**指的是当前这个**对象**的**父类**部分，通俗来说就是**“父亲遗传给我的天赋”**，通过**父对象**可以调用**父类**的**虚拟方法**，并且这个**虚拟方法**是未被该类**覆写**过的**虚拟方法**。
### 5.6.订阅事件
**订阅事件**在**结绳**中是一个关键词，使用**订阅事件**可以订阅一个**对象**的所有**事件**，如果**对象**没有被订阅事件，那么它将不会触发事件。
**订阅事件**的格式很简单：
```
//订阅单个对象
订阅事件 订阅对象
//订阅多个对象
订阅事件 订阅对象1,订阅对象2
//订阅本类所有对象
订阅事件()
```
注意，**成员事件**需要被订阅，而**类事件(父类的虚拟事件)**与**局部事件**不需要订阅。
### 5.7.包
结绳允许同**文件**多**类**，在**类**上方可以声明此**文件**所有**类**的**包名**(不声明会默认包名为应用包名)
```
包名 我的.包
//下面是若干个类
```
注意，**包名*声明时不需要加双引号。
```
//以下代码是错误的
包名 "我的.包"
```
同时，**包名**中间至少要有一个小数点。
```
//以下代码是错误的
包名 我的
```
当**类名**重复时，可以使用**类**的**完整类名**来区分**类**。
包名+.+类名=完整类名
这是文件1:
```
//文件1
包名 我的.包一
类 测试类
    @静态
    方法 测试方法()
    结束 方法
结束 类
```
这是文件2:
```
//文件2
包名 我的.包二
类 测试类
    @静态
    方法 测试方法()
    结束 方法
结束 类
```
它们的**类名**相同，这时候可以使用**完整类名**来区分它们了：
```
我的.包一.测试类.测试方法()
我的.包二.测试类.测试方法()
```
注:目前**完整类名**只能用于使用**静态方法**，用其他地方会报错。
### 5.8.创建
**创建**是一个关键词，表示**创建**该**类**的**实例对象**。
```
创建 类名
```
>结绳4.0没有构造方法，所以创建后面直接跟类名，不需要有额外的参数。

**创建**在结绳4.0不常见，因为结绳4.0的**变量**会**自动创建对象**，不需要你手动创建。
```
//声明参考变量，参考变量默认为空
变量 测试 为 对象?
//为参考变量手动赋值
测试 = 创建 对象
```
## 6.专有名词名单
### 6.1.空对象/空(null)
null是一个特殊的值，它表示某个变量或引用不引用任何对象或值。可以将null视为一个空的或不存在的引用。
null通常用于以下情况：
 - 当对象还没有被实例化时，可以将对象引用设置为null。
 - 当对象不再需要时，可以将其引用设置为null，这样垃圾收集器可以回收该对象占用的内存空间。需要注意的是，null是一个特殊的值，是一种“无”的状态，并不等同于空文本、空数组或空指针。而且，在访问null引用的方法或属性时，会抛出NullPointerException异常。因此，在编写代码时，需要小心处理null值，避免出现空指针异常，并使用相应的条件判断来处理null引用。
### 6.2.面向过程编程(ProceduralProgramming)
**面向过程编程**是一种基于**过程**和**函数**的编程方法。在**面向过程编程**中，**程序**被看作是一系列顺序执行的**过程**，每个**过程**通过完成特定的任务来实现**程序**的功能。它将**程序**分解为一系列的**过程**或**函数**，这些**过程**依次执行，并按照**程序**的逻辑顺序协同工作。
**面向过程编程**的主要特点包括
**1. 顺序执行**：**面向过程编程**强调按照指定的顺序执行**过程**或**函数**。**程序**从头到尾依次执行每个**过程**，每个**过程**完成一个具体的**任务**。
**2. 函数和过程**：**面向过程编程**使用**函数**或**过程**来封装特定的功能或任务。**函数**是接受输入参数并返回特定结果值的代码单元，**过程**则是不返回结果的**函数**。
**3. 全局数据和局部数据**：在**面向过程编程**中，**程序**通过使用**全局变量**来共享数据。这意味着任何**过程**都可以访问和修改**全局变量**。同时，每个**过程**也可以定义自己的**局部变量**，这些**变量**仅在**过程**内部可见。
**4. 顺序控制**：**面向过程编程**使用控制结构(如果语句和循环语句)来控制程序的执行流程。通过这些**结构**，**程序**可以根据特定的条件执行不同的逻辑分支，或者多次执行相同的逻辑块。
**5. 数据驱动**：在**面向过程编程**中，数据通常被视为驱动**程序**的重要组成部分。**程序**通过操作和修改数据来完成**任务**，数据和操作数据的过程是密切相关的。**面向过程编程**主要用于解决一些简单和直线的问题，通常较适合于小型和较简单的应用程序。一些使用面向过程编程的语言包括C和Fortran。
### 6.3.面向对象编程(object-oriented programming/OOP)
**面向对象编程**是一种编程范式，它将程序设计问题视作**对象**之间的相互作用。在**面向对象编程**中，程序被组织成**对象**，每个**对象**都有自己的状态和行为，并能通过与其他**对象**的交互来实现任务的完成。
面向对象编程的核心概念包括**封装、继承和多态。**
**[封装(Encapsulation)]**是指将特定数据和对这些数据的操作捆绑在一起，形成一个**对象**。**对象**可以暴露一些公共**方法**来允许其他**对象**访问和操作其内部状态，同时隐藏不必要的细节和实现细节。
**[继承(Inheritance)]**允许创建一个新的**类**，这个**类**继承了现有的类的特性和行为，并且可以添加或修改一些新的特性和行为。继承提供了代码重用的机制，并且使得代码更加可维护和可扩展。
**[多态(Polymorphism)]**指的是通过一个**类**的**对象**调用其**父类**的方法时，实际执行的是**子类**覆盖了**父类**的**方法**的实现。**多态**提供了一种灵活的方式来处理不同类型的**对象**，使得代码可以根据上下文动态地调用不同**类**的**方法**。**面向对象编程**的优点包括代码的重用性、可维护性和可扩展性。通过将大型程序划分为多个小的、可重用的**对象**，可以更容易地理解和修改程序的不同部分。**面向对象编程**还可以提高代码的模块化程度，使得程序开发更加高效和可靠。
### 6.4.面向函数编程(FunctionalProgramming)
**面向函数编程**是一种基于**函数**的编程方法。它将计算视为**数学函数**的求值，强调使用**纯函数(pure function)**来处理**数据**。**纯函数**是指给定相同的**输入**，总是返回相同的**输出**，且没有副作用。**面向函数编程**避免使用**可变状态**和**共享状态**，更加注重**函数**之间的数据流和转换。
**面向函数编程**具有以下特点：
**1. 函数是一等公民**：在**面向函数编程**中，**函数**被视为一等公民，可以像其他数据类型一样作为参数传递给其他**函数**、**赋值**给**变量**或返回其他**函数**。
**2. 不可变数据**：**面向函数编程**强调使用**不可变数据结构**，避免在**函数**内部修改**数据**。这有助于减少并发编程中的竞态条件和错误。
**3. 高阶函数**：**面向函数编程**支持**高阶函数**的概念，即可以接受其他**函数**作为**参数**或返回**函数**作为结果的**函数**。这种能力可以帮助构建更抽象、模块化和可复用的代码。
**4. 递归**：**递归**在**面向函数编程**中被广泛采用，用于解决复杂的问题。**递归函数**通过反复调用自身来处理问题，直到达到基本情况或终止条件。
**5. 引用透明性**：在**面向函数编程**中，**函数**的**返回值**仅依赖于其输入参数，而不依赖于外部状态。这种特性称为**引用透明性**，方便代码的测试和推理。
**面向函数编程**通常用于处理数据转换和处理，数学计算和算法实现等领域。它的一些流行的语言包括Haskell、Scala和Clojure。面向函数编程的优点包括代码简洁、可维护性好、并发处理理念清晰等。
### 6.5.安卓组件(AndroidComponents)
**安卓组件**是构建**安卓应用程序**的基本构建块，每个**组件**都有特定的**功能**和**生命周期**。以下是一些常见的**安卓组件**：
**[活动/窗口/Activity]窗口**是用户界面的基本单元，代表**应用程序**中的一个屏幕。它负责与用户交互，并处理用户输入，**窗口**可以包含**可视化组件**、**布局组件**和**逻辑代码**，通过**启动信息(Intent)**启动其他**窗口**。
**[服务/Service]服务**是在**后台**运行的**安卓组件**，独立于**用户界面**。它可以执行长时间运行的操作，如下载文件、播放音乐或处理网络请求。**服务**没有用户界面，并且可以在**后台**持续运行，即使用户切换到其他**应用程序**。
**[广播接收器/Broadcast Receiver]广播接收器**是一种能够**接收**和**响应系统**或其他**应用程序**发送的**广播消息**的**组件**。它可以用于接收**系统事件**(如电池电量变化、短信到达等)或其他**应用程序**发送的**自定义广播**。
**[内容提供者/信息提供商/ContentProvider]内容提供者**是一种通过统一的接口来**管理**和**共享应用程序**的数据的**组件**。它通过对外提供**URI(统一资源标识符)**来访问和修改数据，可以在应用程序之间实现数据共享和交互。
### 6.6.堆栈(stack)
**堆栈**是一种**数据结构**，用于存储和管理数据的一种方式，遵循**后进先出(LIFO)**的原则。在**堆栈**中，最后添加的元素首先被移除，类似于将物体堆叠在一起的方式。
**堆栈**由两个基本操作组成：
**[入栈/压栈/Push]**将**元素**添加到**堆栈**的顶部，即将新**元素**放置到**堆栈**的顶部位置。
**[出栈/Pop]**从**堆栈**的顶部删除并返回**元素**，即移除堆栈中的顶部**元素**。
堆栈还有一些其他操作：
**[栈顶/Top]**获取**堆栈**中顶部**元素**的**值**，而不将其删除。
**[栈空/空栈/Empty]**检查堆栈是否为空，即不包含任何元素。
**堆栈**常常用于解决需要按照特定顺序管理数据的问题。例如，可以使用**堆栈**来实现**方法**调用的跟踪，存储**程序**的执行状态，在逆序处理**文本**，以及回退历史记录等。
在计算机中，**堆栈**通常以一片连续的**内存区域**来实现，由**指针**来表示**堆栈**的顶部**元素**。当新**元素**被添加到**堆栈**时，**栈顶指针**向上移动；当**元素**被弹出时，**栈顶指针**向下移动。
需要注意的是，**堆栈**的大小有限，超过其容量会导致**溢出**。这种情况称为**堆栈溢出/爆栈(Stack Overflow)**。因此，在使用**堆栈**时，需要确保操作的合理性，以避免出现这种情况。
### 6.7.线程(thread)
**线程**是在操作系统中最小的执行单位，也可以理解为轻量级的**进程**。一个**进程**可以包含多个**线程**，每个**线程**可以同时执行不同的**任务**。
**线程**的主要特点包括：
**[并发执行]线程**可以独立**运行**，并发执行不同的**任务**。多个**线程**可以同时执行，从而提高**程序**的**效率**和**响应性**。
**[共享资源]线程**在同一个**进程**中共享相同的**内存空间**和**资源**，因此可以**访问**和**共享**相同的**全局变量**、**文件**等。
**[轻量级]**相比于**进程**，**线程**的**创建**和**切换**消耗的资源较少，也更容易管理和调度。
线程主要有两种类型：
**[用户级线程/User-Level Threads]**这种**线程**是由**应用程序**自身管理的**线程**，操作系统并不感知它们的存在。它由**应用程序**中的**线程库**提供支持，并在**应用程序**内部进行**管理**和**调度**。
**[内核级线程/Kernel-Level Threads]**这种**线程**由操作系统内核**创建**和**管理**。操作系统可以将**线程**映射到底层多个处理器上并进行真正的并行执行。
**线程**在**多任务处理**、**并发编程**和**异步操作**等方面发挥着重要作用。它们可以协调处理多个**任务**，改善系统的响应性，并实现并发执行的效果。然而，**线程**也带来了**线程安全**和**同步**等问题，需要合理**管理**和**处理**共享**资源**的访问。
在许多**编程语言**中，如Java、C++和Python等，提供了**线程库**或**框架**，使得开发者可以方便地**创建**和**管理线程**。这些**库**提供了各种**线程**相关的**功能**和**机制**，如**创建线程**、**同步操作**、**线程**间的**通信**等，简化了**线程**编程的复杂性。
### 6.8.指针(pointer)
**指针**是计算机编程中一个重要的概念，它是存储**内存地址**的**变量**。简单来说，**指针**指向计算机**内存**中的一个**特定位置**。
指针可以通过两个基本操作来使用：
1. 取地址（Address-of）：通过使用"&"符号，可以获取变量的内存地址并将其赋给一个指针变量。
2. 解引用（Dereference）：通过使用"*"符号，可以访问指针变量所指向的内存地址处存储的值。指针的主要作用和用途包括：
3. 内存管理：通过指针，可以动态地分配和释放内存，使程序能够灵活地管理和操作内存资源。
4. 传递参数：指针可以用于在函数之间传递参数，通过传递变量的内存地址而不是实际值，可以实现在函数间共享和修改变量的值。
5. 数据结构：指针可以用于构建和操作复杂的数据结构，如链表、树和图等。
4. 访问硬件和系统资源：指针可以用于与硬件设备或操作系统交互，通过直接访问内存地址，实现对底层资源的控制和操作。指针的使用需要特别注意一些问题，如指针的合法性、指针的初始化和释放、指针的悬空引用等。指针的错误使用可能引发一些严重的问题，如段错误（Segmentation Fault）和内存泄漏（Memory Leak）等。需要注意的是，不同的编程语言对指针的支持和实现可能不同。例如，高级语言（如Java）可能隐藏了指针的概念，而提供了更高级的、更安全的内存管理机制。但是低级语言（如C和C++）通常直接暴露指针的概念和操作。
## 7.常见异常分析
### 7.1.空指针异常(NullPointerException)
NullPointerException（空指针异常）是一种常见的运行时异常，在代码执行过程中引用了一个空（null）的对象或者引用。
当程序尝试通过一个null引用来调用方法、访问成员变量或者执行其他与对象相关的操作时，就会抛出NullPointerException。这意味着当前操作需要一个非空对象，但实际引用为空，无法执行操作。NullPointerException通常由以下情况引起：
 - 对象引用未经初始化，即没有被赋予一个有效的对象。
 - 引用被显式地设置为null。
 - 引用通过调用方法或者访问成员变量时，被传递给一个期望非空对象的方法或者操作。为了避免NullPointerException的发生，应该在使用对象之前，合理进行非空判断。可以使用条件语句（如if语句）来判断引用是否为null，并根据需要进行相应的处理（如抛出异常、返回默认值等）。此外，良好的编程实践也包括在设计和编写代码时避免出现null引用的情况，例如使用默认值或者空对象来代替null引用。
### 7.2.索引越界异常(IndexOutOfBoundsException)
它是一种常见的运行时异常，在访问数组、集合或字符串等数据结构时使用了超出其有效索引范围的索引值。
当程序中使用一个超出有效索引范围的索引值来访问数组、集合或文本时，就会抛出索引越界异常。这意味着程序试图访问不存在的元素或者访问的范围超过了数据结构的有效范围。索引越界异常通常由以下情况引起：
 - 用一个小于0或大于等于数组、集合或文本长度的索引值进行访问。
 - 在使用索引时，没有正确处理边界条件，导致超过了数据结构的有效范围。为了避免索引越界异常的发生，应该在使用索引之前，进行合理的索引范围检查。可以使用如果语句或循环语句来确保索引在有效范围内，并根据需要进行相应的处理（如抛出异常、返回默认值等）。同时，在编写循环时，需要小心处理索引的增加或减少操作，以确保在有效范围内。良好的编程实践包括使用合适的数据结构和正确处理索引范围，以及进行适当的错误处理，可以有效避免索引越界异常的发生。
### 7.3.类型转换异常(ClassCastException)
它是一种常见的运行时异常，表示试图将一个对象强制转换为不兼容的类类型。
对象之间的类型转换通常使用父类引用指向子类对象，或者将对象从一种类型转换为另一种类型。在进行类型转换时，如果对象的实际类型与目标类型不兼容，就会抛出类型转换异常。
类型转换异常通常发生在以下情况下：
 - 将一个对象强制转换为不是其父类的类型，即将一个不是该类型的对象赋值给一个类的引用变量。
 - 将一个对象转换为不兼容的接口类型。
 - 当试图将一个包含不兼容类型的集合转换为特定类型的数组时。
为了避免类型转换异常，应该在执行类型转换之前，先进行类型检查。可以使用**属于**关键字来判断对象的实际类型，并确保类型转换是合法的。此外，在进行类型转换时，还可以使用容错处理语句来捕获ClassCastException并进行相应的处理，如选择其他适合的类型转换方式或者抛出自定义异常。
## 8.常见问题解决
### 8.1.安卓环境获取问题
当你需要一个安卓环境对象时，你可以直接在**窗口**类中填**本对象**，因为**窗口**间接继承**安卓环境**，在**服务**中也同理，因为**服务**也继承**安卓环境**，在**组件容器**中可以使用**取安卓环境**()或者**取安卓窗口**()来获取安卓环境。
### 8.2.全局共享变量问题
需要在整个**工程**共用一些**变量**，你可以新建一个**类***：
```
@全局类
类 数据存储类
    @静态
    变量 数据1 为 整数
    @静态
    变量 数据2 为 文本
结束 类
```
**类**上标注@**全局类**，同时里面所有**变量**都标注了@**静态**。
这样，你就可以在其他**类**调用这里的**变量**了。
```
类 启动窗口 : 窗口
    事件 启动窗口:创建完毕()
        数据1 = 114514
    结束 事件
结束 类
```
### 8.3.单例获取对象问题
**单例类**是一种特别的**类**，只会**创建**一个**对象**的**类**叫做**单例类**。
为了获取到这唯一的**对象**，我们有两个方案：
**方案1.哪个类的对象哪个类来管**
```
类 启动窗口 : 窗口
    @静态
    变量 实例对象 为 启动窗口?
    事件 启动窗口:创建完毕()
        实例对象 = 本对象
    结束 事件
结束 类
```
在上面的代码可见，**启动窗口**里面**声明**了一个**静态变量**，名称为**实例对象**，但是此时这个**变量**是**空**的，所以还要在创建完毕事件里面给它**赋值**。
一般来说，该方案最好不要在类上标注@**全局类**，因为可能会导致名称混淆及同名重复声明风险。
``` 
类 另一个窗口 : 窗口
    事件 另一个窗口:创建完毕()
        /*
        不要问我为什么要在一个窗口里
        调用另一个窗口的弹出提示
        这个是演示！！！
        */
        启动窗口.实例对象.弹出提示("a")
    结束 事件
结束 类
```
**方案2.让一个类统一来管**
```
@全局类
类 单例对象类
    @静态
    变量 启动窗口对象 为 启动窗口?
    @静态
    变量 其他窗口对象 为 其他窗口?
结束 类
```
声明一个**类**，统一来管这些**对象**，这个类一般标注@**全局类**，这样可以直接忽略**类**调用**对象**了。
当然，这些**变量**实际上还是**空**的，所以还要**赋值**。
```
类 启动窗口 : 窗口
    事件 启动窗口:创建完毕()
        启动窗口对象 = 本对象
    结束 事件
结束 类
```
然后你就可以这样调用了。
```
类 某个窗口 : 窗口
    事件 某个窗口:创建完毕()
        /*
        和上面一样，只是演示
        不要再说“多此一举”了
        */
        启动窗口对象.弹出提示("a")
    结束 事件
结束 类
```
### 8.4.列表类型项目问题
**列表类型**一般指的是**自定义宫格列表框**和**自定义下拉列表框**，实际上它们基本是通用的操作。
在此之前，我们先声明一个**组件容器**，用来表示列表中的一项。
```
类 单项布局 : 组件容器
    @布局配置([[根布局=真,宽度=-1,高度=-1,高度DP=40,背景颜色=-1]])
	变量 根布局 : 相对布局
	@布局配置([[父布局=根布局,@位于布局中间=真,字体大小=16,内容="默认内容"]])
	变量 显示文本 : 文本框
结束 类
```
然后呢，通过**集合模板类**实现一个**组件容器集合**，再然后在**启动窗口**里用一个**组件容器集合**存储所有容器。
```
/*
安卓基本库不自带组件容器集合
所以要自己声明一个集合实现类
*/
类 组件容器集合 : 集合模板类<组件容器>
结束 类
```
这里是启动窗口代码:
```
//呐呐呐，这里就是启动窗口了
类 启动窗口 : 窗口
	//这里是布
    @布局配置([[根布局=真,宽度=-1,高度=-1]])
   	变量 根布局 : 相对布局
   	@布局配置([[父布局=根布局,宽度=-1,高度=-1]])
   	变量 列表 : 自定义宫格列表框
   	@布局配置([[父布局=根布局,@位于布局中间=真]])
   	变量 按钮1 : 按钮
   	//这里是用来存储组件容器的集合
    变量 数据 为 组件容器集合
    //订阅事件
  	事件 启动窗口:创建完毕()
  		订阅事件()
  	结束 事件
  	//单击时添加一个项目
    事件 按钮1:被单击()
        添加列表项目("a")
    结束 事件
    //一个方法
    方法 添加列表项目(项目文本 为 文本)
		变量 容器 为 单项布局
		容器.显示文本.内容 = 项目文本
		数据.添加成员(容器)
		列表.更新项目(数据.长度)
    结束 方法
    //这个事件必不可少
    事件 列表:加载布局(索引 : 整数,项目布局 : 组件容器) : 组件容器
  	    返回 数据.取成员(索引)
  	结束 事件
结束 类
```
### 8.5.资源文件读写问题
首先你需要附加资源，在启动窗口头上附加你的资源文件。
```
@附加资源("../../一份文档入门结绳.md")
类 启动窗口 : 窗口
结束 类
```
有个小技巧，就是你把你的光标放在附加资源上，同时不要动，过一会会弹出一个小图标，点它，你就可以快速选择自己的资源文件了。
然后就是如何读取你的资源文件内容，你可以使用这个方法来读取你的资源文件内容。
```
读入资源文件(安卓环境,文本,文本)
```
安卓环境填什么不用我说了，不懂的看上面的**8.1.安卓环境获取问题**，第二个参数表示要读取的文件名，第三个参数是编码，一般不填。
现在我想读取我刚才附加的资源文件该怎么办？你可以这样来获取：
```
读入资源文件(本对象,"一份文档入门结绳.md")
```
OK，我不仅想要读取，我还想修改它，怎么办，我可以告诉你，资源文件没办法修改的。
接下来就是我不仅想自己读取，我还想复制到其他地方，这该怎么办？也是很简单，用这个方法即可。
```
写出资源文件(安卓环境,文本,文本):逻辑型
```
安卓环境不多说，第二个参数是文件名，也不用说，第三个参数就是写出路径了，然后它还返回一个逻辑型值，一般我们不用理它，写出成功时就会返回真，失败就会返回假，失败的原因可能是你没有文件权限。
现在来试试：
```
写出资源文件(本对象,"一份文档入门结绳.md","/storage/emulated/0/一份文档入门结绳.md")
```
### 8.6.新主线程切换问题
**线程**是什么可以看看第6.7小章，在此不过多阐述。
目前两个方法来使用**线程**：
**方案1.声明线程变量**
```
变量 新线程 为 线程
```
可以声明一个**线程**类的**变量**，然后监听它的两个**事件**。
```
事件 新线程:被启动()
    /*
    线程被启动时触发该事件
    用户可在该事件进行耗时操作
    */
结束 事件
事件 新线程:更新主线程(来源消息 为 消息)
    /*
    线程内部处理器接收到
    发送的消息时触发该事件
    一般在该处进行界面更新处理
    */
结束 事件
```
关于这两个**事件**已经在里面的**注释**写了，不再多言。
一般来说，**线程**有两个常用的**方法**，分别是**启动**()与**中断**()。
**启动**方法表示正式启动该**线程**，并且触发**线程**的**被启动**事件，**线程**的**被启动**事件在**新线程**运行，而不是在主线程。
**中断**方法表示中断该**线程**，但是不会立马中断，只会为该**线程**标记为**中断状态**。
**被启动**事件在**新线程**内运行，但是众所周知，**新线程**不能操作UI布局，否则会报错，所以我们可以使用**线程**的**通知_更新主线程**方法，该方法会触发**线程**的**更新主线程**事件，这个事件在**主线程**运行。
**信息**类也要一起讲一下，它只有两个常用的**属性读**和**属性写**，即**参数**，你可以在此存储你的参数对象，使用**通知_更新主线程**方法时会把参数对象传到**更新主线程**事件里。
**方案2.嵌入式代码线程**
在全局提供了四个主要的**方法**：
```
提交到新线程运行()
//新线程运行的代码
提交到主线程运行(安卓环境)
//主线程运行的代码
结束提交到主线程()
//新线程运行的代码
结束提交到新线程()
```
这个方案最为常用，**提交到主线程运行**需要一个**安卓环境**参数，你可以查看8.1小章得知如何获取**安卓环境**，在此不多阐述。
### 8.7.容错俘获处理问题
**容错处理**是全局的套**嵌入式代码**语句，其常用三个方法。
```
开始俘获异常()
//可能发生错误的代码
俘获所有异常()
//发生错误后运行的代码
结束俘获异常()
```
如果**开始俘获异常**方法到**俘获所有异常**方法之间报错了，那么**异常**会被**俘获**，应用程序因此不会而终止运行，并且，开始运行**俘获所有异常**方法到**结束俘获异常**方法之间的代码，如果没有报错则不运行。
在**俘获所有异常**方法到**结束俘获异常**方法之间可以使用一个方法来获取俘获到的**异常**。
```
取俘获异常()
```
该方法返回一个**异常**对象，该对象就是你俘获的**异常**。
### 8.8.网络工具使用问题
**网络工具**常用的就只有一个**方法**：
```
//要求网页返回一个数据，即post
发送数据(网址 : 文本,
欲发送数据 : 对象,
cookie : 文本 = 空,
超时 : 整数 = 6000,
编码 : 文本 = "UTF-8")
```
与此**方法**配套的两个**事件**是：
```
//网页返回数据成功，结果为返回的数据
发送数据结束(结果 为 文本,
内容 : 字节[],
cookie 为 文本)
//网页发送数据失败，即超时或返回空
发送数据失败()
```
注意，**网络工具**的同步**方法**最好不要使用，因为网络操作必须在**新线程**(**异步**)中进行，否则会**报错**。
## 9.通用数据格式
### 9.1.JSON
JSON是JavaScript Object Notation(JS对象格式)的缩写，它是一种轻量级的数据交换格式。JSON格式以键值对的形式存储数据，可以表示简单的数据结构，比如数字、文本、逻辑等，也可以表示复杂的数据结构，比如数组和对象。JSON数据采用类似于JavaScript对象的语法，并且可以被多种编程语言解析和生成。它在Web开发中广泛应用于数据传输和存储，常用于前后端之间的数据交互。
JSON的语法非常简洁明了，以下是一些常见的JSON语法规则：
 - 键值对：数据由键和值组成，使用冒号:分隔，每对键值对之间使用逗号,分隔。键必须是一个字符串，值可以是文本、数字、逻辑、数组、对象或者空。
 - 对象：用花括号{}表示对象，对象中的键值对之间使用逗号,分隔。例如{ "name": "John",  "age": 25,  "isStudent": true}
 - 数组：用方括号[]表示数组，数组中的元素之间使用逗号,分隔。例如：["apple", "banana", "orange"]
 - 值：可以是文本(必须用双引号括起来)、数字、逻辑(true或false)、对象、数组或空。例如："Hello World"/42/true/null这些只是JSON语法的基本规则，JSON还支持嵌套、转义字符等特性。
### 9.2.XML
XML(可扩展标记语言)是一种用于描述数据的标记语言。它采用标签的形式来定义和组织数据，具有良好的可扩展性和通用性。XML广泛应用于数据交换、配置文件、文档标记和Web服务等领域。
XML的基本特点如下：
 - 标签结构：XML使用起始标签和结束标签来标识数据的开始和结束，并使用嵌套的方式形成树形的结构。例如：
```xml
<book>
  <title>XML Basics</title>
  <author>John Doe</author>
  <year>2022</year>
</book>
```
 - 自定义标签：与HTML不同，XML标签不是预定义的，可以根据具体的需求自定义标签名。这使得XML更加通用，适用于各种应用领域。
 - 属性和值：XML标签可以带有属性和属性值，用于提供额外的描述信息。例如：
```xml
<book category="science" price="29.99">...</book>
```
 - 嵌套和层次结构：XML支持将标签嵌套在其他标签中，形成层次结构。这使得数据能够以更有组织的方式进行表示，并提供了更大的灵活性。
 - 文本内容：XML标签可以包含文本内容，用于表示具体的数据值。例如，上述示例中的
```xml
<title>XML Basics</title>
 ```
 标签就包含了文本内容"XML Basics"。
 - 扩展性：XML具有良好的扩展性，可以根据需要定义自己的文档结构和标签。这使得XML可以适应不同的数据模型和应用场景。
XML通过标签和数据的结构化描述，使数据可以以独立于平台和应用的方式进行存储、传输和解析。在许多领域中，XML是一种重要的数据交换和配置文件标准，并且有很多相关的工具和技术可以用于处理和操作XML数据。
XML的语法规则相对简单明确：
 - 声明：XML文档的开始部分通常包含一个XML声明，用于指定XML版本和编码方式（可选）。
```xml
   <?xml version="1.0" encoding="UTF-8"?>
   ```
 - 标签（元素）：XML使用起始标签和结束标签来定义数据的开始和结束。标签可以是自闭合的（在起始标签后加上“/”），也可以是具有嵌套关系的。
```xml
   <标签名>内容</标签名>
   <自闭合标签名 属性="值" />
   ```
 - 属性：标签可以带有属性和属性值，用于提供额外的描述信息。属性位于起始标签中，属性名和属性值通过等号连接。
 ```xml
   <标签名 属性名="属性值">内容</标签名>
   ```
 - 注释：XML中可以使用注释来添加对数据的说明和解释。注释以“<!--”开头，以“-->”结尾。
```xml
   <!-- 这是一个注释 -->
   ```
 - CDATA节：当XML中包含需要保留原始格式的文本时，可以使用CDATA节来声明。CDATA节以“<![CDATA[”开头，以“]]>”结尾。
```xml
   <![CDATA[这是需要保留原始格式的文本]]>
   ```
 - 实体引用：某些特殊字符在XML中具有特殊意义，需要进行转义，使用实体引用表示。例如，`&lt;`表示小于符号“<”。
```xml
   &lt;title&gt;This is a title.&lt;/title&gt;
   ```
XML的语法规则简洁明了，具有良好的可读性和可扩展性。它的灵活性使得XML能够适应不同的数据结构和应用场景，并且易于解析和处理。
### 9.3.MD
MD文件是一种纯文本格式的文件，它以.md为扩展名，通常用于编写简单的文档、笔记、Readme文件等。MD代表Markdown，是一种轻量级的标记语言，最初由约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）在2004年创建。
MD文件的特点是简单易读、易写，可直接用普通文本编辑器打开和编辑。它使用一些易于理解的标记符号来定义文本的样式、格式和结构。
MD文件可以通过将其转换为HTML格式在网页上显示，也可以转换为其他格式，如PDF、Word等。因此，MD文件在编写技术文档、博客文章、项目文档、文档说明等方面被广泛应用。
MD文件使用Markdown语法进行标记和格式化文本。
下面是Markdown常用的语法示例：
\# 一级标题
\## 二级标题
\### 三级标题
\#### 四级标题
\##### 五级标题
\###### 六级标题
文本左右\*表示斜线
文本左右\*\*表示粗体
文本左右\=\=表示高亮
文本左右\~\~表示删除
文本左右\~表示下标
文本左右\^表示上标
\>后面跟着引用内容
\[link\]\(网址网址或文件路径\)
\!\[Alt\]\(图片网址或文件路径\)
\!\[Alt\]\(图片网址或文件路径=长×宽\)
\`单行代码\`
\`\`\`编程或标记语言
多行代码
\`\`\`
这些是最常用的MD标记，还有很多可以自行百度。
## 10.可视化布局
### 10.1.自适应布局
**自适应布局**是一个**布局组件**，用于自定义**布局**的位置和尺寸。
**自适应布局**使用**绝对坐标**来定位子组件**，每个**子组件**的位置是使用其左上角的**绝对坐标**来指定的。这意味着**子组件**的位置和尺寸是固定的，不会随着屏幕或父布局的大小而改变。尽管**自适应布局**提供了精确的位置和尺寸控制，但它已经被安卓官方不推荐使用，因为它的**布局**效果在不同屏幕尺寸和设备上可能会出现问题。推荐使用更灵活和适应性更强的**布局组件**。
### 10.2.线性布局
**线性布局**是一个**布局组件**，**线性布局**以线性的方式排列**子组件**，可以水平或垂直地摆放**子组件**。
**线性布局**是最常用的**布局组件**之一，特别适用于有序排列的**子组件**，它简单易用，但布局相对固定，灵活性相对较低。
### 10.3.相对布局
**相对布局**是一个**布局组件**，它允许**子组件**相对于**父布局**或其他**子组件**进行摆放。
**相对布局**具有很高的灵活性和自由度，可以实现各种复杂的布局效果，如层叠组件、嵌套组件、相对位置控制等。它适用于需要灵活排列子组件的场景，但相对布局层级比较复杂时，可能会影响性能。
### 10.4.宫格布局
**宫格布局**是一个**布局组件**。它以网格的方式排列**子组件**，可以灵活地创建行列布局。
**宫格布局**适用于复杂的网格布局，例如表格、图形排列等场景。它提供了强大的布局功能，能够快速创建灵活自适应的网格布局，同时还可以控制子组件的对齐和大小，使布局更加灵活和美观。但是相对于其他布局组件，**宫格布局**的性能要稍差一些，因为布局较为复杂。
### 10.5.纵横滚动布局
**滚动布局**是一个**布局组件**，**横向滚动布局**和**滚动布局差不多。**滚动布局**提供了滚动功能，可以在需要展示超出屏幕可见范围的内容时使用。
**滚动布局**只能有一个**子组件**，这个**子组件**一般是一个**布局组件****滚动布局**常用于需要显示较长内容的界面，可以将内容放置在**滚动布局**的**子组件**中，通过滚动来查看所有内容。它使得用户能够在有限的屏幕空间内浏览大量内容，并提供了方便的滚动操作。但需要注意的是，滚动布局只能在一个方向上滚动，并且使用过多的滚动布局可能会影响性能。
### 10.6.卡片布局
**卡片布局**是一个**布局组件**，**卡片布局**提供了更多装饰功能，如圆角等。
### 10.7.分页布局
**分页布局**是一个**布局组件**，**分页布局**提供了页面滑动功能，添加页面需要使用**组件容器**。
### 10.8.侧滑布局
**侧滑布局**是一个**布局组件**，其提供了设置两边侧滑栏的功能，两边侧滑栏布局需要使用**组件容器**设置(注:该布局组件只能为根布局)
### 10.9.单选框布局
**单选框布局**是一个**布局组件**，其类似**线性布局**，只不过其**子组件**只能为单选框，在勾选一个布局内单选框后其他单选框会取消。
### 10.10.组件容器
**组件容器**是布局中最常用的**类**之一，其用于存储布局，你需要先**声明**一个**继承**它的**类**，然后长按设计布局即可。
```
类 我的容器 : 组件容器
    //长按代码设计布局
结束 类
```
要使用这个**组件容器**，你可以创建其**对象**。
```
分页布局1.添加页面(创建 我的容器)
```
### 10.11.提示框
**提示框**就是你弹出提示的那个框，你可以自定义**提示框**来设计和应用软件风格一致的布局。
```
变量 提示 为 提示框
提示.自定义布局 = (创建 我的容器).取根布局()
提示.显示()
```
### 10.12.对话框
**对话框**就是平常你们看到的那种对话框，可以使用原生对话框：
```
变量 对话 为 对话框
对话.标题 = "标题"
对话.信息 = "信息"
对话.按钮1 = "按钮1"
事件 对话:按钮1被单击()
    对话.关闭()
结束 事件
对话.显示()
```
你也可以通过组件容器自定义布局：
```
变量 对话 为 对话框
对话.自定义布局 = 创建 我的容器
对话.显示()
```
### 10.13.悬浮窗
**悬浮窗**可以被随意拖动并且悬浮于窗口之上，你可以申请全局悬浮权限，来让悬浮窗可以全局使用，并且悬浮窗需要你使用组件容器自定义布局，多个悬浮窗需要指定标记，否则悬浮窗标记重复会覆盖之前的悬浮窗。
>什么？你们还在玩结绳？真的不考虑一下来玩玩书契吗？你问书契是什么？书契和结绳一样也是个应用啦。什么？你说你不会Java，要是会Java早就去玩书契了？好吧，等你学会Java，来QQ群648412327加入书契吧。

