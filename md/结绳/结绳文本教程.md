【必看介绍】
[文档谁写的]
编写于2024年5月25日
这个文档作者: Futility-老无
QQ: 1531679317
后宫群: 680298680
有好的建议，可以进结绳官方群艾特老无反馈。

//子结束
//结束
[结绳是什么]
结绳是一款安卓中文编程软件，
你可以在结绳里面使用结绳中文(TieCode)编程语言开发程序，
也就是说，结绳是一个应用软件，而结绳中文是一个编程语言。
有了它，你可以在手机上，编写你想要的安卓软件
坐着，躺着，站着，都可以写，不受姿势限制。


//子结束
//结束
[结绳在哪下载]
官网，官方群，均可下载，有问题请进官方群交流。
结绳官网:
http://www.tiecode.cn/

结绳官方一群:
938828067

结绳官方二群:
1074469442

老无的后宫交流群:
680298680

书契官网:
https://www.qiplat.com/


//子结束
//结束
[进群需要注意什么]
首先，友善交流，不要随意吵架，讨论不良风气，
禁止讨论政治敏感话题，色情，等违法内容。
禁止讨论外挂，脚本。反编译，开盒。


//子结束
//结束
[哪里能学]
CSDN博客
哔哩哔哩
本文档
结绳官方交流群


//子结束
//结束
[收费标准]
结绳官方曾说过永久免费，具体解释权归结绳官方所有。

//子结束
//结束
【使用注意事项】
[订阅事件]
排在第一，说明这个非常重要，订阅事件后，所有事件才会生效，否则除了创建完毕的事件，通通不执行。只有在窗口和组件容器类里才需要订阅，并且需要在类事件订阅，订阅一次即可。每个窗口都需要订阅，每个组件容器需要在容器执行事件就需要订阅。
用法:

类 窗口1:窗口

    事件 窗口1:创建完毕()
        订阅事件()
        订阅事件
        //这两种用法都对，用一个就行，每个窗口都要订阅
        //特殊情况，组件容器也需要订阅事件
    结束 事件

结束 类



//子结束
//结束
[申请权限]
软件运行需要权限，如存储权限，拍照权限

用法:

类 窗口1:窗口

    事件 窗口1:创建完毕()
        申请所有权限()
        订阅事件
        //新手推荐这种用法，系统会自动识别添加权限
        //进阶其他特殊权限，需要另外动态申请，这个方法可以满足大部分需求。
        
        //推荐两个一块使用，申请权限和订阅事件，都是必要的
    结束 事件

结束 类

//子结束
//结束
[?]
一个特殊的存在。

在文本判断中，可以判断是否包含。

如果 数据1 ? "你好"
  弹出提示("包含")
否则
  弹出提示("不包含")
结束 如果

在创建变量里，可代表为空变量，部分变量没有直接创建，只能为空。

变量 文本1:文本?
变量 集合1:集合?
变量 哈希表1:哈希表?
变量 位图1:位图对象?

//子结束
//结束
[注释//]
这个双//，在结绳的语法中，作用是注释掉一行代码，让其不生效。不参与代码执行。
注释不会影响程序运行的速度
注意，注释只能用在句首，不能用在句尾。

正确示例

    //我是注释掉的代码
    弹出提示("你好")
    //我是注释掉的代码

错误示例
    
    弹出提示("你好，结绳")//我是注释掉的代码
    //这里会直接报错，因为注释不能用在句尾
    


示例:
    
    // 变量 数据1:文本
    这里的代码不会执行，会变成灰色
    
//子结束
//结束

[/* */ 多行注释]
/*为注释开头，*/为注释结尾，作用批量注释代码。文本，让其不参与代码执行。
注释不会影响程序运行的速度
    
    /*
    变量 数据1:文本 = "你好"
    变量.....
    */
    
    
   变成灰色，不参与执行

//子结束
//结束
[运行java或其他代码]
结绳支持运行java代码。

单行特殊代码，code做前缀。如，java

code return 123;

多行特殊代码，@code开头，@end结尾，如。

@code
String sj1;
int aa = 456;
return aa;
@end

//子结束
//结束
[变量方法等使用位置]
比如

类 窗口1:窗口
//这里是类的开头，一般用来创建可视化布局

//一般情况，类里只能运行申请变量。
变量 数据1:文本 ＝ "你好"

//直接运行方法等，会报错，因为不支持
//下面是错误示例。
弹出提示("你好，结绳")


    //下面是正确示例
    事件 窗口1:创建完毕()
        弹出提示("你好，结绳")
        // 这里，可以直接弹出，正常运行
  
        主题初始化()
        //自定义方法，主题初始化也能正常运行
    结束 事件

    //错误示例，方法不能在类里直接运行。
    主题初始化()

    方法 主题初始化()
        文本框1.字体大小 = 18
    结束 方法


结束 类


//子结束
//结束

[可视化布局器]

类 窗口1:窗口
    //重点:可视化布局器，只能在窗口类，或者组件容器类使用，如
    /*
    类 窗口1:窗口
    //这就是窗口类
    */
    
    /*
    类 容器1:组件容器
    //这就是组件容器类
    */
    
    //长按类里的空白处，弹出选项，选择设计布局，在选择可视化布局，进入可视化布局器。
    //tly布局为进阶，新手不建议使用
    
    //设计完毕，返回，会自动生成布局文件，新手不建议去改，因为一不小心就会崩溃报错，强烈建议用可视化布局器


结束 类

//子结束
//结束
[命名规则]
结绳的标识符标准和其他大部分编程语言的一样，但是支持中文
也就是说，不能以数字开头，可以包含数字的中文标识符
中间也不能有符号和空格之类的东西
比如

    变量 整数 1:整数
    //这就是错误的命名，因为整数和1中间有空格
    
    变量 1 整数:整数
    //这也是错误的命名，因为不能以数字开头
    
    变量 整数1:整数
    //这是正确的命名规则，同样，变量名，方法名，事件名，类名等，命名规范都是按照这个规则。可以纯中文，结绳主导的就是纯中文编程


//子结束
//结束

[参数使用规则]

在结绳中，自定义方法，软件自带方法，自定义事件，和自带事件等，参数均不修改。这是重点。
请结合自定义方法等整体来理解这个规则

错误示例:
    方法 自定义方法1(参数1:文本)
        参数1 = "你好"
    结束 方法
    //错误原因，结绳不支持直接修改参数，这里的参数1就是参数，只能读取，不允许赋值修改
    
    
正确示例:
    方法 自定义方法2(参数2:文本)
        变量 参数3:文本 = 参数2
        参数3 = 参数3 + "你好"
        弹出提示(参数3)
    结束 方法
    //结绳不允许直接修改，但是可以读取出来再修改，
    
//子结束
//结束
[绳包安装]
绳包，就是扩展库。
用户可以自定义绳包，用来创建属于自己的快捷代码工具
如，自己写一个方法，用来获取屏幕信息，或者数组排序等。

也可以自定义封装组件，当组件不能满足自己的需求，可以通过绳包来扩展。

方法一
右上角设置，安装绳包，选择绳包文件。
安装完毕后，在左侧侧滑栏长按绳包，选择管理绳包并勾选。
部分没有管理绳包，长按绳包目录后，弹出的对话框是可以上下滑动的
滑动到底部就会有个安装绳包

方法二
文件管理等，选择用结绳打开。

方法三
直接进文件夹，把绳包复制进项目绳包目录。


//子结束
//结束

[&& 与 且]
这个一般出现在判断里，判断多个条件。

示例

    如果 a > 0 && a < 10

    结束 如果

    如果 a > 0 且 a < 10

    结束 如果

且就是&&，他们两个是一样的，用来判断多个条件同时满足。

//子结束
//结束
[ || 与 或]
这个一般出现在判断里，判断多个条件其中的一个。

示例

    如果 a > 0 || a < 10

    结束 如果

    如果 a > 0 或 a < 10

    结束 如果

或和 ||，他们两个是一样的，多个条件中，有一个满足就会执行。
//子结束
//结束
[ : 与 为]

: 冒号，是结绳中一种缩写，: 等于 为，他们两个是一样的。
示例

    变量 数据1:文本 = "你好"
    变量 数据2 为 文本 = "结绳"

为建议左右留空格，防止误判。
//子结束
//结束

[结绳的关键词]
    关键词目前有：
    "包名", "类", "结束 类"，"变量", "常量"
    "方法", "结束 方法"，"属性写", "属性读", "结束 属性",
    "事件", "定义事件", "结束 事件"，"结束", 
    "为", "真", "假", "空", 
    "本对象", "父对象",
    "如果", "则", "否则", "结束 如果"
    "循环", "跳过循环"，"退出循环"，
    "结束 循环"，"假如", "是", "结束 假如"
    "订阅事件", "属于", "本对象"，"父对象"，
    "返回", "创建"

//子结束
//结束
[结绳的注解词]
目前有
    隐藏，静态，调试，禁止调用，禁止继承，废弃使用(文本)，属性需求.方法名(值)，运算符重载，外部Java文件(文本)，全局基础类。
    主题配置...，全局主题(文本)，窗口主题(文本)，后缀代码(文本)，前缀代码(文本)，嵌入式代码，国际化。
    布局配置(文本)，禁止创建对象，外部依赖库...，外部动态库(文本)，虚拟事件，输出名(文本)。
    指代类(文本)，全局应用，强制输出，导入Java(文本)，虚拟方法，附加资源(文本)，安卓资源...。
    附加清单...，编译时处理参数，附加可变清单...，附加权限(文本)，全局类，异步方法，需求值类型(类)。
    常量类型(类)，匹配文件(文本)，值输出规则(文本)，外部基础类(文本)，Native构建，软件配置...。

//子结束
//结束
【数据类型】
[类型介绍]
    在结绳中，类型有文本，整数，小数，单精度小数，逻辑型，集合，文本集合等。
    静态，等同于Java中的static关键词。
    这些类型，均可定义为变量和常量，区别在于，
    变量，可以随时修改，可以改变的类型。
    常量，从创建成功开始，便不允许修改。
    
    除了变量，和常量，还有静态变量，非静态变量，静态方法，非静态方法。
    
    类 自定义1
    
        @静态
        变量 数据1:文本 = "你好"
        
        @静态
        常量 数据2:文本 = "你好"
        
        @静态
        方法 输出数据() : 文本
            返回 数据2
        结束 方法
    
    结束 类
    
    静态的作用，就是可以不创建类，也能读取到该数据，通过 类名.变量名，或类名.方法名调用。
    静态变量，只能在静态方法或以类名为前缀调用。
    
    如:
        弹出提示(自定义1.数据1)
        弹出提示(自定义1.输出数据())
        
        
        
//子结束
//结束
[文本]
Java 对应 String

文本型变量，需要双引号。
用法:

    变量 数据1:文本 = "你好，结绳"


赋值方法:

    变量 数据1:文本
    数据1 = "你好，结绳"

这里的数据1，就是变量名。


//子结束
//结束
[整数]
Java 对应 int
范围:-2147483648 至 2147483647

用法:

变量 数据1:整数 = 123

赋值方法:

变量 数据1:整数
数据1 = 123

这里的数据1，就是变量名。


//子结束
//结束
[小数]
Java 对应 double
范围:1.7e-308 至 1.7e+308
也叫双精度浮点数。

用法:

变量 数据1:小数 = 1.001

赋值方法:

变量 数据1:小数
数据1 = 1.001

这里的数据1，就是变量名。


//子结束
//结束
[逻辑型]
Java 对应 Boolean
默认为假，也就是false
真为true，只能有真或者假。

用法:

变量 数据1:逻辑型 = 真

赋值方法:

变量 数据1:逻辑型
数据1 = 假

这里的数据1，就是变量名。

//子结束
//结束
[单精度小数]
Java 对应 float
范围:3.4e-38 至 3.4e+38

用法:

变量 数据1:单精度小数 = 1f

赋值方法:

变量 数据1:单精度小数
数据1 = 1f

这里的数据1，就是变量名。


//子结束
//结束
[长整数]
Java 对应 long
范围:-9223372036854775808 至 9223372036854775808

用法:

变量 数据1:长整数 = 1000l

赋值方法:

变量 数据1:长整数
数据1 = 1000l

这里的数据1，就是变量名。


//子结束
//结束
[大数字]
Java 对应 BigInteger
范围，理论上无穷无尽，常用于超大数计算。

用法:

变量 数据1:大数字 = 1000000000

赋值方法:

变量 数据1:大数字
数据1 = 100000000

这里的数据1，就是变量名。


//子结束
//结束
[字符]
Java 对应 char
代表任意文本或整数字符。

用法:

变量 数据1:字符 = 100
变量 数据1:字符 = "你好，结绳"
变量 数据1:字符 = "abcd"

赋值方法:

变量 数据1:字符
数据1 = 100

这里的数据1，就是变量名。


//子结束
//结束
[字节]
Java 对应 byte
范围:-128 至 127

用法:

变量 数据1:字节 = 100

这里的字节，不一定是整数，
数据流，视频流，等，就是这个字节流。
单个是字节，字节数组就是字节流。
可代表任何数据。

//子结束
//结束
[数组]
通用型。索引从0开始。
比如一个长度为3的数组，索引就是，0,1,2
用法:

变量 一维:文本[] = {"你好","结绳"}

数据用{}括起来。每个长度用,分开。
结绳创建数组，会在第一次赋值自动锁定长度。

用法:

变量 一维:整数[] = {123,456,789}

这是一个一维数组，第一个文本长度为2，第二个一维整数数组有3个长度。

多维数组用法:

变量 二维:整数[][] = \{\{123,321\},{456,654}}

{123,321}是一个一维数组，{456,654}也是一维数组
合起来就是二维数组，二维文本数组同上。

变量 三维:整数[][][]
变量 四维:整数[][][][]

.....以此类推

指定长度。

变量 一维:整数[2]
一维 = {123,234}

一维[0] 结果就是 123
一维[1] 结果就是 234

变量 二维:整数[2][2] = \{\{121,234\},{654,666}}
变量 三维:整数[2][2][2] = \{\{\{111,222\},\{333,444\}\},\{\{555,666\},\{777,888\}\}\}

多维以此类推....

二维[0][0] 结果就是 121
二维[0][1] 结果就是 234
二维[1][0] 结果就是 654
二维[1][1] 结果就是 666

其他多维，以此类推。


//子结束
//结束
[数组拓展知识]
<=> 这是一个特殊的符号，用来直接交换数组内容

例如在冒泡排序循环中。
    变量 数据1:整数[]
    //假设数据1已经有数据，现在进行冒泡排序
    
    方法 冒泡排序测试(数据:整数[])
        变量 临时:整数[] = 数据
        循环(a,0,取数组长度(临时) - 1)
            循环(b,0,取数组长度(临时) - a - 1)
                 临时[i] <=> 临时[i + 1]
            结束 循环
        结束 循环
    结束 方法

//子结束
//结束

[取数组长度]

获取数组长度的方法就是取数组长度

示例

    变量 数组1:整数[] = {1，2}
    变量 长度:整数 = 取数组长度(数组1)
    弹出提示(长度)
    
    //这时候，弹出的结果就是2，因为数组1只有两个参数。
    //不仅仅可以用于整数数组，文本数组，字节数组等，用起来一模一样以此类推。
    
//子结束
//结束
[集合]
Java 对应 List<>

用法:

变量 数据1:集合
变量 数据2:文本 = "你好，结绳"
变量 数据3:整数 = 123456

数据1.添加成员(数据2)
数据1.添加成员(数据3)

集合的添加成员方法，需要传入一个参数，参数为任意数据对象。

这时候，数据1的长度，就是2，索引也是从0开始。

集合就像一个仓库，可以把任意普通数据放进去。比如，货架扔进仓库，球拍扔进仓库。


//子结束
//结束
[集合拓展知识]
集合，除了添加成员方法命令还有以下方法。
    变量 集合1:集合
    变量 数据1:文本 = "你好"
    集合1.添加成员(数据1)
    
    添加成员(数据:对象)
//用法
    集合1.添加成员(数据1)
    
    ?
    返回逻辑型，?标识是否包含该数据对象
//用法
    变量 逻辑1:逻辑型
    逻辑1 = 集合1 ? 数据1
    调试输出(逻辑1)
    //这里，输出的结果就是真，因为前面添加了数据1，集合里确实存在这个数据
    
    
    集合1[索引:整数]:对象
//用法
    变量 临时:文本 = 集合1[0]
    //这时候，临时的内容就是集合1索引为0的数据"你好"
同时，可以直接赋值
//用法
    集合1[0] = "结绳"
    注意，因为这里，集合1在前面已经创建了，并且赋值了一个变量，因此此时长度为1，所以可以直接赋值。
    
//用法
    集合1[10] = 对象
    这是错误写法，因为集合现在没有那么长的长度，这样直接运行会超出索引，可以用添加成员，先改变集合长度再修改。
    

    删除成员(索引:整数)
//用法
    集合1.删除成员(0)
    这里，会直接从集合1里面删除索引为0的数据对象。
    
    
    删除成员2(数据:对象)
//用法
    变量 临时2:文本 = "你好"
    集合1.删除成员2(临时2)
    //这里会按数据对象，找到对象来删除成员，开头我们有一个数据1的文本变量，内容是你好，这里临时2的数据也是你好，相同，
    因此，这里会直接删除
    
    变量 临时3:整数 = 123
    集合1.删除成员2(临时3)
    这里，会查找和临时3一模一样的数据对象来删除，很显然，集合1里并没有这个对象，所以，本次代码不会删除任何数据
    
    到数组():对象[]
//用法
    新建一个集合2
    变量 集合2:集合
    //假设，这里集合2添加的全是文本数据，且只有一层文本数据。
    变量 临时:文本[] = 集合2.到数组()
    //执行到数组命令，就会返回一个文本数组给临时文本数组
    
    如果，集合2里添加的全是整数数据，且只有一层
    变量 临时2:整数[] = 集合2.到数组()
    //执行到数组命令，这里返回的就会是整数数组。
    
    取成员(索引:整数):对象
//用法
    变量 临时3:文本 = 集合1.取成员(0)
    这里的用法，和，集合1[0]是一模一样的，都是为了取成员，
    也就是说， 集合1[0] = 集合1.取成员(0)
    都是传入索引参数，都会返回一个数据对象
    
    寻找成员(数据:对象):整数
//用法
    调试输出(集合1.寻找成员("你好"))
    //这里，会在控制台输出0，因为这里"你好"是一个文本数据对象，当给寻找成员传入参数后，会返回该数据所在的索引，也就是0
    
    打乱集合()
//用法
    集合1.打乱集合()
    这个没有参数，执行该方法，会打乱所有集合的位置。
    
    插入成员(索引:整数,数据:对象)
//用法
    集合1.插入成员(0,"结绳")
    //这个方法有两个参数，第一个索引，比如输入0，原来的数据就会向后位移1个，如果不够，会自动扩增一位，第二个参数就是要插入的数据对象。
    //执行该方法后，集合1里就有两个数据对象，第一个已经改变，就是刚刚插入的"结绳"，索引就是0，原来位置的"你好"向后位移到第二位，索引也就是1。
    
    是否为空():逻辑型
//用法
    调试输出(集合1.是否为空())
    //这时会输出结果为假，因为集合已经有数据，该方法不需要参数，有数据会返回真，没有数据会返回假，用来判断整个集合是否为空集合。

    是否存在(数据:对象):逻辑型
//用法
    变量 临时:逻辑型 = 集合1.是否存在("你好")
    这时，临时的结果就是真，是否存在()和前面的?一个用法
    集合1.是否存在(数据1) = 集合1 ? 数据1
    
    
    清空()
//用法
    集合1.清空()
    运行清空方法，就会清空集合1的所有数据。
    
    置成员(索引:整数,数据:对象)
//用法
    集合1.置成员(0,"结绳")
    //这时就会把集合1索引为0的数据替换成结绳，置成员就是替换
    
    长度
//用法
    这里，长度是一个属性，返回一个集合的整数长度
    弹出提示(集合1.长度)
    这时，就会弹出一个提示，内容就是集合的长度，一个数据就返回1，两个数据就返回2
    
    
    集合注意事项
    集合可以添加任意数据类型对象，比如，文本，整数，甚至自定义类，哈希表，等等等等。
    
    在使用跟索引有关的，应先确定是否存在该索引，否则会超出索引报错。
    比如，删除成员，取成员，插入成员，置成员，这些在输入索引之前，建议通过长度判断，如果索引不在长度范围内，自然不存在该索引，就会崩溃报错。
    
//子结束
//结束
[文本集合]
Java 对应 List<String>
一个特殊的集合，只能存文本。

用法:

变量 数据1:文本集合 = {"12345","你好"}

类似数组，但是只能存文本进去。


//子结束
//结束
[位图对象]
Java 对应 Bitmap
一种特殊的图片类型。

用法:

变量 数据1:位图对象 = 位图对象.从路径创建位图("存储卡详细路径")

变量 数据1:位图对象?
数据1 = 位图对象.从路径创建位图("存储卡详细路径")

//子结束
//结束
[图片资源]
图片资源是一个比较特殊的资源，在安卓原生开发中有个文件夹drawable。
项目内的附加文件叫资源，图片资源就是读取项目内的资源，这个变量禁止创建对象，看看具体示例。

记得在类前或方法前附加资源。附加是将图片打包进apk

@附加资源("../../资源/图标/全屏.png")
类 启动窗口:窗口

用法1
    变量 图片1:图片资源 = "../../资源/图标/全屏.png"
    图片框1.图片资源 = 图片1
    这时候，图片1就是资源里的图片，全屏.png，在实际运用过程中，单击=右边，会弹出一个小灯泡，点击灯泡可以快速输入路径。
    
用法2
    常量 图片1:图片资源 = "../../资源/图标/全屏.png"
    图片框1.图片资源 = 图片1
    

//子结束
//结束
【变量范围说明】
[局部变量]
局部变量，就是只在局部才能使用的变量。
比如:

类 启动窗口:窗口

  事件 启动窗口:创建完毕()
    订阅事件
    变量 数据1:整数 = 123
    
    弹出提示(数据1)
    //可以运行，因为局部变量创建在事件内，弹出提示也在事件内。
  结束 事件
  
  事件 按钮1:被单击()
      弹出提示(数据1)
    //不可运行，因为和局部变量是在不同的事件。
  结束 事件


结束 类


//子结束
//结束
[类变量]
可以运行在一整个类的变量，
比如:

类 启动窗口:窗口

  变量 数据1:整数 = 123
  事件 启动窗口:创建完毕()
    订阅事件
    
    数据1 = 456
    弹出提示(数据1)
    //可以运行，因为在同一个类，这里提示的结果就是456。
  结束 事件
  
  事件 按钮1:被单击()
    数据1 = 789
    弹出提示(数据1)
    //可以运行，因为在同一个类，这里提示的结果就是789。
  结束 事件


结束 类


//子结束
//结束
[全局变量]
顾名思义，全局，在任意类里都可以使用的变量。

使用方法:
//先自定义一个新类，类前标记为全局类

@全局类
类 全局数据
  @静态
  变量 数据1:整数 = 123

结束 类

类 启动窗口:窗口
  
  事件 启动窗口:创建完毕()
    订阅事件
    弹出提示(数据1)
    //可以运行，因为是全局类，这里提示的结果就是123。
    
    
    数据1 = 456
    弹出提示(数据1)
    //可以运行，这里提示的结果就是456。
    
  结束 事件
  

结束 类

类 窗口2:窗口
  事件 窗口2:创建完毕()
    订阅事件
    
    全局数据.数据1 = 789
    弹出提示(全局数据.数据1)
    //可以运行，这里是第二个类，全局数据是类名，数据1是变量名。
    //这是标准用法，前两个是快捷用法，带上类名，避免自己混乱。
  结束 事件

结束 类


//子结束
//结束
【常用方法】
[调试输出]
    用于把一段文本数据，输出到结绳控制台，调试用。
用法:

    调试输出("调试信息")
    //这里就传入了一个文本信息输出

    暂时有bug，不一定会完全输出，一般不建议使用。


//子结束
//结束
[弹出提示]
用于弹出一个简短的文本提示。

构造:
弹出提示(内容: 对象, 长时显示 : 逻辑型 = 假)

有两个参数，第一个内容对象，可以是文本，也可以是整数等，，最终结果都会转化为文本。
第二个，一般默认为假，也就是短时间显示

用法:

   弹出提示("你好，结绳")

   弹出提示("你好，结绳"，真)

因为第二个参数有默认值，不用时可以忽略


//子结束
//结束
[倒计时器]
    变量 倒计时1:倒计时器
		倒计时1.开始倒计时(3000,0)
		//第一个参数是倒计时多少秒，第二个参数是过多久执行，0就是立即执行。1000就是一秒后开始倒计时。
		
		事件 倒计时1:正在倒计时(剩余时长 : 长整数)
			//这里可以写出时间，或者中断倒计时
		结束 事件
		
		事件 倒计时1:倒计时结束()
			//这里写倒计时结束的事件
		结束 事件

//子结束
//结束
[定时器]

用来循环间隔一段时间执行一个事件，关闭后无法再次启动。
示例

    变量 定时1:定时器
    
    事件 启动窗口:创建完毕()
        定时1.开始定时(5000,0)
        //启动定时器
        //一共有两个参数，第一个5000是每五秒运行一次，第二个0为立即执行，1000就是一秒后执行
    结束 事件
    
    事件 定时1:周期事件()
        弹出提示("你好，结绳")
    结束 事件
    //当定时器被启动，每五秒会弹出一次提示，执行一次事件
    
    //关闭定时器，注意，定时器被关闭后，无法再次启动，需要创建新的定时器。
    定时1.关闭()

//子结束
//结束
[时钟]
类似于定时器，但是时钟可以暂停，重启。

用法

    变量 时钟1:时钟
    
    事件 启动1:创建完毕()
        时钟1.时钟周期 = 3000
    结束 事件
    
    事件 时钟1:周期事件()
        弹出提示（"你好，结绳"）
    结束 事件
    
    //暂停时钟
    时钟1.时钟周期 = 0
    
    //重新赋值即可重新运行
    时钟1.时钟周期 = 3000

    
//子结束
//结束
[随机数]
取随机数，结绳提供了以下两种方法

    取随机小数(最小值 为 小数,最大值 为 小数) 为 小数
    取随机数(最小值 为 整数,最大值 为 整数) 为 整数
    
    第一种取随机小数示例。
    变量 小数1:小数 = 取随机小数(1.01,6.01)
    
    //这里，就成功获取了一个随机小数，最小值为1.01，最大为6.01，该方法会在这个范围内获取一个随机小数返回给变量，小数1。
    
    第二种取随机整数示例
    变量 整数1:整数 = 取随机数(0,10)
    
    //这个取随机数方法，会在0到10之间取一个随机整数，返回赋值给整数1
    
//子结束
//结束
[随机颜色]
    取随机颜色(支持透明度 : 逻辑型 = 真) : 整数
    这个方法，可以返回一个十进制的整数颜色，可以为负数，参数逻辑型控制是否支持透明度设置
    
    使用示例
    变量 颜色1:整数 = 取随机颜色(真)
    
    这时，颜色1就成功获取了一个随机颜色，并且，参数为真，代表支持随机透明度。


//子结束
//结束
[自增或自减]
    结绳提供有自增和自减的快捷方法，构造为
    
    自增(数字 : 变体型, 自增值 : 变体型 = 1)
    自减(数字 : 变体型, 自减值 : 变体型 = 1)
    
    这两个方法，第一个参数为变体型，变体型是相当灵活的类型，这是结绳特有封装的，类型包括不限于，整数，小数，数值，字符串，对象等。
    在自增和自减方法里，一般整数和小数用的比较多，自增和自减，第一个参数是什么类型，第二个参数也是相同类型。
    
    使用示例
        变量 数据1:整数 = 2
        自增(数据1,1)
        这里，数据1的结果就是3。
        自增(数据)
        这里，数据1的结果也是3。
        
        自增(数据1,4)
        这里，数据1的结果就是4
        
        自增第一个传入需要自增的对象名，第二个传入需要增加的值，每运行一次，自增一次。
        
        变量 数据2:整数 = 10
        自减(数据1,1)
        这里就是自减，和自增使用方法一样，但是一个是增加，一个是减小，这里数据4的结果就是1，这里的自减，第二个参数是1。
        运行本次自减方法，结果就是9
        
        自减(数据2)
        这时数据2的结果也是9
        
        自减(数据2,5)
        这时数据2的结果就是5

//子结束
//结束
[计次循环]

循环(i, 起始, 次数)
循环(赋值变量[可空],起始值[可空，不填默认为0]，终止值)

用法:

    变量 数据1:整数 = 0
    循环(a,0,100)
        数据1 = 数据1 + 1
    结束 循环
    弹出提示(数据1)

    //这里会弹出结果提示，结果是99，循环了100次
    //计次循环，第一个参数为存储计数的变量，为整数，第二个参数为开始循环的位置，
    //这里是0，从0开始，第三个为循环结束的位置，这里是100，循环到100结束，100不执行

//子结束
//结束
[判断循环]

循环(逻辑型条件)

用法:

    循环(真)
        //需要循环的代码
    结束 循环
    //注意，这是无限循环，使用应该注意代码规范，控制好中断或者提交到线程，否则会卡死主线程，使软件崩溃
    
    变量 数据1:逻辑型 = 假
    循环(数据1)
        //需要循环的代码
    结束 循环
    
    // 这里传入了一个逻辑型条件变量，当数据1为真的时候，会开始循环，否则停止循环

//子结束
//结束
[枚举循环]
循环(集合 -> 值)
循环(集合1->项目)
循环(哈希表1->键,值)

释义，枚举循环可以直接取出值，常用于数组，集合，哈希表等。
->  枚举，你存进去是什么类型，取出来就是什么类型
比如
变量 文本1:文本集合  //假设有数据
循环(文本1 -> 临时)
那么这里的临时，就是一个文本1的文本数据，也可以理解为，还有下一个。
不用再创建变量接收，可直接使用，循环的是整数，那取出来就是整数，是类，取出来就是类。
用法:

    变量 数据1:文本[100]
    //这里创建了一个文本数组，长度为100，假设，有100个数据，内容分别是数据1，数据2，数据3，以此类推
    循环(数据1 -> 临时)
    //循环的代码....
        调试输出(临时)
    结束 循环
    //如此循环，便会打印出所有数组的内容，等于把每个数组的内容给取出来赋值到临时变量。
    
    变量 数据2:文本集合
    //假设数据2也有100和数据
    循环(数据2 -> 临时2)
        //循环的代码....
        调试输出(临时2)
    结束 循环
    //这样，文本集合的数据，也会循环打印出来，其他自定义类，集合等，均可用此方法执行

    循环(哈希表1->键,值)
    //还是属于枚举循环，第一个参数为哈希表实例对象，第二个为键名，逗号,后的参数，就是取出来的值

//子结束
//结束
[跳过循环]
用来跳过一次循环

示例

    循环(a,0,5)
        如果 a == 3
            跳过循环
        结束 如果
        调试输出(a)
    结束 循环
    //这里只会输出4条数据，因为在a等于3的时候，跳过了本次循环，但是后面的循环还会继续执行
    //输出的结果分别是，1，2，4，5

//子结束
//结束
[退出循环]
用来中断循环，常用于条件循环的无限循环

示例

    变量 数据1:整数 = 0
    循环(真)
        数据1 = 数据1 + 1
        调试输出(数据1)
        如果 数据1 == 5
            退出循环
            //这里使用了关键字退出循环，条件满足会退出结束这个循环
        结束 如果
    结束 循环

//子结束
//结束
[判断运算符]
== 是否相同
!= 是否不等于
< 小于条件
> 大于条件
<= 小于等于
>= 大于等于
|| 或者
&& 并且

//子结束
//结束
[单个条件判断]
示例:

    变量 数据1:逻辑型
    如果 数据1 == 真
        调试输出("数据为真")
        //数据1为真的时候，运行这里的代码
    否则
        调试输出("数据为假")
        //数据1为假的时候，运行这里的代码
    结束 如果

    
//子结束
//结束
[多个条件判断]
示例:

    变量 数据1:逻辑型
    变量 数据2:整数 = 100
    
    如果 数据1 == 真 && 数据2 == 100
        调试输出("数据为真")
        //数据1为真并且数据2为100，运行这里的代码，两个条件必须同时满足
    否则
        调试输出("数据为假")
        //两个条件有任意一个不满足，运行这里的代码
    结束 如果
    
    //或者用法示例
    如果 数据1 == 真 || 数据2 > 0
        调试输出("数据为真")
        //只要有一个条件满足，就会运行这里的代码
    否则
        调试输出("数据为假")
        //两个都不满足，运行这里的代码
    结束 如果

    //这里示例的是两个条件判断，判断三个，四个等，以此类推
    //多个条件判断注意事项，条件运算，需要用()括起来，否则会识别错误报错
    
    示例:

    如果 数据1 == 真 && (数据2 + 10) == 110
        //这里运行满足的代码
        //已知数据2为100，这里运算加了10，所以这里两个条件都满足
    否则
        //这里运行不满足的代码
    结束 如果

    
//子结束
//结束
[嵌套判断]
用于多个条件判断

示例

    变量 数据1:整数
    如果 数据1 == 1
        //当数据1为1的时候执行这里的代码
    否则 数据2 == 2
        //当数据1为2的时候执行这里的代码
    否则 数据3 == 3
        //当数据3为1的时候执行这里的代码
    否则
        //所有条件都不满足执行这里的代码
    结束 如果



//子结束
//结束
[假如语句]

    假如，等同于Java中的switch，是一个分支判断语法。

    示例
    
    变量 数据:整数
    
    假如 数据
        是 0
        //这里执行数据为0的分支
        
        是 1
        //这里执行数据为1的分支
        
        是 2
        //这里执行数据是2的分支
        
        是
        //这里执行所有分支都判断后都不满足的代码
        
        结束 假如
        //   结束语句
        
再比如，文本
        变量 姓名:文本
        
        假如 姓名
            是 "张三"
                //这里执行姓名是张三的代码
            是 "李四"
                //这里执行姓名是李四的代码
            是 "王麻子"
                //这里执行姓名是王麻子的代码
            是
                //这里执行所有分支都不满足的代码
        结束 假如
        //   结束语句

//子结束
//结束
[数学运算]
+ 加
- 减
* 乘
/ 除
% 百分比
用法示例

    变量 数据1:整数 = 10
    变量 结果:整数
    //结果用来存计算结果
    //示例1
        结果 = 数据1 + 100
        //这里，就是相加，结果就等于110
    //示例2
        结果 = 数据1 -50
        //这里，结果就是-40
    //示例3
        结果 = 数据1 * 10
        //这里，结果就是100
    //示例4
        结果 = 数据1 / 5
        //这里，结果就是2
    //示例5
        结果 = 数据1 % 2
        //注意，这里10的百分之二，结果应该是0.2，但是因为结果是整数型变量
        //因此，这里会直接给转整数，结果为1，常用于取余数

//子结束
//结束
[自定义方法]
一个软件运行，有时候需要多次执行重复的代码，这里可以用自定义方法解决

示例
    //创建一个自定义方法，位于类级别，名称是方法1

    方法 方法1()
        调试输出("我是自定义方法")
        //这里写自己需要重复的方法
    结束 方法

    //调用的时候，
    方法1()
    //这便直接调用了方法1，每调用一次，执行一次里面的代码

除了上面的普通自定义方法，还可以给方法设定多个初始参数，多个参数之间用,隔开
示例:
    创建一个计算加法的方法，有两个整数，第一个参数名是临时1，没有默认值
    第二个参数名是临时2，有默认值，方法名是整数相加测试。

    方法 整数相加测试(临时1 : 整数,临时2 : 整数 = 10)
        变量 结果 : 整数 = 临时1 + 临时2
        调试输出(结果)
        //这里，会调试输出两个参数相加的结果，
        //参数活学活用，这里只正确示例
    结束 方法

    //调用
        整数相加测试(100)
        //这时会运行这个方法，并调试输出结果为110
        //因为我们第二个值有默认值，因此没有数据会自动默认
        
        整数相加测试(10,20)
        //这时会输出结果30，因为两个参数都传入了指定值，默认参数就无效。

    参数空白用法示例

    方法 测试方法(数据1:整数 = 10，数据2 : 整数)
        调试输出(数据1 + 数据2)
    结束 方法
    
    测试方法(,100)
    //这时会输出结果为110，因为第一个有默认值，空参数就要用,区分，如果不写,
    //100就会默认先给参数1，那第二个参数就成了空白，第二个没有默认值，就会报错

    参数除了传入整数，还可以传入文本，小数，逻辑型，集合，数组，文本集合等所有类型数据，方法可以递归自己调用自己
    
    带返回值的方法示例

    方法 文本相加(参数1:文本,参数2:文本,参数3:文本 = "测试数据"):文本
        变量 数据1:文本 = 参数1 + 参数2 + 参数3
        返回 数据1
    结束 方法

    //调用
    弹出提示(文本相加("你好"，"结绳"，"我爱结绳")

    //这里会弹出一个提示，内容是，你好结绳我爱结绳，
    //代码先执行了带返回值的方法将三个参数文本相加，再弹出提示
    //这里的返回值，可以是任意基本类型的不一定非要用文本
    
    
    
    注意事项
        在结绳中，方法内参数只可以读取，不可以写入，不管是自定义的方法，还是自带的，又或者所有事件，所有方法，都不允许直接修改。
        参数只能在调用的时候修改
    
    错误示例
        方法 测试数据(参数1:整数 = 0)
            参数1 = 10
            调试输出(参数1)
            //这是错误写法，因为结绳不允许直接修改
        结束 方法
    
    正确示例

        方法 测试数据(参数1:整数 = 0)
            变量 数据1:整数 = 参数1
            数据1 = 参数1
            调试输出(数据1)
            //这是正确写法，可以在读取后赋值给新变量，然后修改新变量，达到预设的效果。
        结束 方法

//子结束
//结束
[返回]
    返回 关键词，用于返回一段数据，
    Java 对应 return，
    常用在自定义方法，事件，等，返回只返回数据，返回不等于中断停止，只能用来返回数据
    正确示例:
        自定义一个方法，并且带返回值，执行该方法，返回一个文本数据
        
        方法 自定义方法1(参数1:文本):文本
            返回 参数1 + ",结绳"
        结束 方法
        
        然后我们调用一下，
        
        弹出提示(自定义方法("你好"))
        这时候，会弹出结果，"你好，结绳"
        虽然我们在这个自定义方法只传入了你好，但是返回处增加了,结绳，两个文本相加。
        
    错误示例:
        方法 自定义2(参数1:文本)
            返回 参数1
        结束 方法
        
        这时候，如果调用会报错，原因是自定义方法结尾，并没有标明返回类型，因此这个方法不支持返回数据。
        
    错误示例:
        方法 自定义3(参数1:文本):文本
            弹出提示(参数1)
        结束 方法
        
        这时候也会报错，因为虽然设置了返回类型，但是方法缺少返回数据
        由此可见，返回命令，和设置方法返回类型，缺一不可。

//子结束
//结束
[遍历集合]
    遍历，就是循环读取所有的数据
    假设，我们创建了一个集合，加入了一堆文本对象，并且把他循环读取出来。
    
    示例
    
    变量 集合1:集合
    循环(a,0,30)
        集合1.添加成员("数据" + a.到文本())
    结束 循环
    //这样就创建了一个集合，且集合里面全是文本
    
    循环(a,0,集合1.长度)
        变量 临时:文本 = 集合1.取成员(a)
        调试输出(临时)
    结束 循环
    
    //这样就会一行一行输出，因为集合内部都是对象，并不清楚你存进去的是什么数据，所以需要提前声明变量，给赋值出来，
    比如存进去的是文本，那么循环声明的变量也是文本，然后通过取成员给取出来，再调试输出。
    
    
    再比如:  文本集合
    文本集合就比较好理解，因为知道是文本，取出来自然也是文本。
    
    变量 数据1:文本集合 = {"数据1","数据2","数据3","数据4"}
    循环(数据1 -> 临时)
        //这里直接使用枚举循环，临时就是从数据1取出来的文本
        调试输出(临时)
    结束 循环
    
    也可以
    
    循环(a,0,数据1.长度)
        调试输出(数据1[a])
    结束 循环

//子结束
//结束
[遍历数组/循环输出数组]
    遍历，就是循环读取所有的数据
    
    示例
    
    变量 数组1:整数[] = {12,67,34,89,4577,245}
    
    循环(a,0,取数组长度(数组1))
        //弹出提示(数组1[a].到文本())
        调试(数组1[a].到文本())
        
        变量 临时数据:整数 = 数组[a]
        调试输出(临时数据.到文本())
    结束 循环
    
    上面两种方法，运行一种即可，都是先读取数组内容，再输出。
    
    如需一次性全部输出，请看示例
    
    变量 数组1:整数[] = {12,67,34,89,4577,245}
    变量 数据:文本
    循环(a,0,取数组长度(数组1))
        数据 = 数组1[a].到文本()
    结束 循环
    调试输出(数据)
    
    这个就是先把所有的数字读入到数据里，再进行一次性输出。
    
    文本数组等同理。
    
//子结束
//结束
【数据类型转换常用】
[转换精度最高-最低排序]
结绳现有变量中，精度从最高到最低依次排序为。

大数字 -> 小数 -> 单精度小数 -> 长整数 -> 整数 -> 字节 -> 逻辑型

在转换过程中，可能会出现精度丢失的情况，请结合实际，合理运用。
例如

    变量 数据1:小数 = 0.3
    弹出提示(数据1.到整数())
    
    弹出的结果会是1，结绳会自动向上取整。
    
部分不同数据类型之间，无法直接转换，可先转换为文本，再转换为对应数字，但是注意，这里不可避免会有精度损失的问题。
    
[到文本]
    首先是到文本()，一切数字类型的数据，都可以转到文本，例如。
    变量 数据1:整数 = 123456789
        调试输出(数据1.到文本())
或
    变量 数据2:单精度小数 = 10.0f
        调试输出(数据2.到文本())


//子结束
//结束
[其他数据类型]
    变量 数据1:文本 = "12"
    变量 数据2:整数 = 数据1.到整数() + 3
    弹出提示(数据2)
    //这时候的结果就是15
    
    结绳的转换方法有:
    到文本()，到整数()，到单精度小数()，到小数()，到逻辑型()，到长整数()，到字节集()。
    
    等等方法，这些都是比较常用的。


//子结束
//结束
【文本操作常用】
[是否相同命令]
    ==
    示例
    变量 数据1:文本 = "abcd"
    //变量 数据2:逻辑型 = (数据1 == "测试数据")
    如果 数据1 == "你好"
        弹出提示("相同")
    否则
        弹出提示("不同")
    结束 如果
    
    很明显，这个不成立，所以弹出不同。

//子结束
//结束
[是否不同命令]
    !=
    示例
    变量 数据1:文本 = "abcd"
    //变量 数据2:逻辑型 = (数据1 != "测试数据")
    如果 数据1 != "你好"
        弹出提示("相同")
    否则
        弹出提示("不同")
    结束 如果
    
    很明显，这个成立，所以弹出相同。

//子结束
//结束
[是否包含命令]
    ?
    示例
    变量 数据1:文本 = "abcd"
    //变量 数据2:逻辑型 = (数据1 ? "c")
    如果 数据1 ? "c"
        弹出提示("包含")
    否则
        弹出提示("不包含")
    结束 如果
    
    很明显，这个包含c，所以弹出包含。

//子结束
//结束
[是否为空命令]
    为空()
    
    示例
    变量 数据1:文本 = "abcd"
    //变量 数据2:逻辑型 = (数据1.为空())
    如果 数据1.为空()
        弹出提示("空白")
    否则
        弹出提示("不是空白")
    结束 如果
    
    很明显，这个有数据，不是空白，所以弹出不是空白。

//子结束
//结束
[复制自身命令]
    *
    数学运算里是相乘，文本则是复制
    示例
    变量 数据1:文本 = "abcd"
    变量 数据2:文本 = 数据1 * 2
    
    弹出提示(数据2)
    //显示的结果，就是 abcdabcd，2就是复制多少次。
    
//子结束
//结束
[文本相加命令]
    示例
    变量 数据1:文本 = "你好"
    变量 数据2:文本 = "结绳"
    变量 数据3:文本 = 数据1 + 数据2
    弹出提示(数据3)
    
    //这时候，结果就是"你好结绳"

//子结束
//结束
[倒找文本命令]
构造
倒找文本(寻找内容 为 文本,开始位置 为 整数 = -1) 为 整数
    顾名思义，倒着查找指定位置，结绳的索引是从0开始。
    该命令有两个参数，第一个为需要查找的文本，第二个参数是要从哪里开始查找。
    找到就返回对应索引，找不到就返回-1。
    示例
    变量 数据1:文本 = "abcdabcd"
    变量 数据2:整数 = 数据1.倒找文本("b")
    
    弹出提示(数据2)
    //这时候，结果就是5，因为是从结尾开始寻找的。第二个参数默认是-1。
    
    变量 数据2:整数 = 数据1.倒找文本("b",4)
    
    弹出提示(数据2)
    //这时候，结果就是1，因为第二个参数4，代表指定从索引4开始往前倒着寻找，4对应"a"
    
    
//子结束
//结束
[分割文本命令]
分割文本，就是将一段文本用指定字符分割成一维文本数组。
示例
    变量 数据1:文本 = "a#b#c#d#vhh#m"
    变量 数据2:文本[] = 数据1.分割文本("#")
    
    弹出提示(取数组长度(数据2))
    //这时候，结果就是6，以#号将指定文本分割成了6个数据
    
    弹出提示(数据2[1])
    //这时候，结果就是b，因为索引从0开始。
    
//子结束
//结束
[删首尾空命令]
去除文本的首尾空格回车等空字符。
示例
    变量 数据1:文本 = "   123    "
    弹出提示(数据1.删首尾空())
    //这时候，结果就是"123"，因为去除了首尾空格。
    
//子结束
//结束
[截取文本命令]
方法 截取文本(开始文本 为 文本, 结束文本 为 文本,包含截取符 : 逻辑型 = 假) 为 文本

在结绳中，截取文本有三个参数，分别是，开始文本，结束文本，包含截取符。

示例
    变量 数据1:文本 = "123456789"
    变量 数据2:文本 = 数据1.截取文本("","5")
    //这时候，数据2的结果就是"1234"
    
    变量 数据2:文本 = 数据1.截取文本("","5",真)
    //这时候，数据2的结果就是"12345"
    
    变量 数据2:文本 = 数据1.截取文本("2","5")
    //这时候，数据2的结果就是"34"
    
    变量 数据2:文本 = 数据1.截取文本("5","9",真)
    //这时候，数据2的结果就是"56789"

错误示例
    变量 数据2:文本 = 数据1.截取文本("5","")
    //这时候，就会直接崩溃，因为，结尾不允许为空，开头可以
    
//子结束
//结束
[替换文本命令]
示例
    变量 数据1:文本 = "abcdbef"
    变量 数据2:文本 = 数据1.替换("b","7")
    //这时候，数据2的结果就是"a7cd7ef"，这个命令会将所有指定字符全部替换。
    
    第一个参数为想要替换掉的字符，第二个参数为你想要改变的新字符。
    
//子结束
//结束
[翻转文本命令]
示例
    变量 数据1:文本 = "123456"
    弹出提示(数据1.翻转文本())
    
    //这时候，结果就是"654321"
    作用是将一段文本翻转过来。

//子结束
//结束
[取指定位置文本命令]
示例
    变量 数据1:文本 = "abcdefg"
    
    变量 数据2:文本 = 数据1.取文本左边(3)
    //数据2的结果就是"abc"，这个命令传入的参数是一个整数
    
    变量 数据2:文本 = 数据1.取文本中间(3,5)
    //数据2的结果就是"def"，第一个参数是开始的索引，第二个是结束的索引，文本不包含索引对应的字符。
    
    变量 数据2:文本 = 数据1.取文本右边_长度(3)
    //数据2的结果就是"efg"，这个命令传入的参数是一个整数长度
    
    变量 数据2:文本 = 数据1.取文本右边(1)
    //数据2的结果就是"bcdefg"，这个命令传入的参数是一个整数索引

//子结束
//结束
[查找文本位置命令]
构造方法
寻找文本(寻找内容 为 文本, 开始位置 为 整数 = 0) 为 整数

有两个参数，第一个为想要查找的内容，第二个为开始的索引，结果返回一个整数索引。

示例
    变量 数据1:文本 = "abcdabcd"
    变量 数据2:整数 = 数据1.寻找文本("c")
    //这时候因为第二个参数默认为0，从0开始查找c，结果就是2
    
    变量 数据2:整数 = 数据1.寻找文本("c",3)
    //这时结果就是6，因为指定了从索引3也就是d开始查找。

//子结束
//结束
【数学运算常用】
[四舍五入方法]
    四舍五入在结绳中，常用于固定小数点后精度。如
    
    变量 数据1:小数 = 3.1415926
    变量 数据2:小数 = 四舍五入(数据1,2)
    
    这时候，结果就会保留到3.14，注意，结绳并不会自动进位或退位，
    比如3.14，四舍五入不会是3.10，
    3.16四舍五入，也不会是3.20
    
//子结束
//结束
[取余数方法]
结绳中并没有提供直接取余数的方法。
比如，数字10，比较值是3，余数就是1，也就是10 ÷ 3 。
已知 3×3＝9  那么10 - 9 =1，常用于判断是否为奇数，单数。

示例
    变量 数据1:整数 = 10 % 3
    
    这时候，数据1就是1，10%3是小数，赋值给整数类型自动转换就是1

//子结束
//结束
【编码转换操作】



//子结束
//结束
【JSON数据常用】


//子结束
//结束
【网络操作工具常用】
[取网页源码]
    变量 网络1:网络工具
    
    网络1.取网页源码("https://www.baidu.com")
    // 注意，取网页源码需要在事件或方法里调用。
    
    事件 网络1:取网页源码结束(结果 : 文本,内容 : 字节[],cookie : 文本)
        弹出提示(结果)
    结束 事件
    
//子结束
//结束
[GET提交请求]
GET请求，和取网页源码基本上一样，都是直接获取。
https://m.baidu.com/from=1030335w/ssid=0/s?pn=10&usm=2&word=结绳是什么
这是一个典型的GET示例，所有的数据都暴露在网址中。

https://m.baidu.com/from=1030335w/ssid=0/s这个就是目标网址，
目标网址和get数据之间用?隔开。
pn=10，pn就是参数名，10就是数据，每个数据之间用&隔开。
word=结绳是什么，word就是参数名，结绳是什么，就是数据，实际运行会进行转码。

我们get时，按照对应数据，把网址给组合起来，直接访问取取源码即可。

更复杂的get，有的会需要cookie，以及ua设置，否则数据可能会错乱，上述方法可应对大部分get请求。

//子结束
//结束
[POST提交请求]
    // 抗揍云登录post示例
    
    变量 账号:文本 = "123456"
	变量 密码:文本 = "645312"
	变量 数据:文本 = "task=3&uid=" + 账号 + "&pwd=" + 密码
	变量 网址:文本 = "https://up.woozooo.com/mlogin.php"

    变量 网络1:网络工具
    网络1.发送数据(网址,数据)
    //发送数据在事件或方法里执行
    
	事件 网络1:发送数据结束(结果 : 文本,内容 : 字节[],cookie : 文本)
		弹出提示(结果)
		//根据结果文本，自行判断是否登录成功
	结束 事件
	
	//部分post，网站还会需要提供cookie，以及UA等参数，这些需要在发送数据之前添加，示例。
	
	
	变量 请求头名称:文本 = "User-Agent"
	变量 请求头文本:文本 = "Mozilla/5.0 (Linux; U; Android 10; zh-CN; 2014811 Build/QQ3A.200805.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.2564.116 Quark/3.8.2.126 Mobile Safari/537.36 T7/10.3 SearchCraft/2.6.3 (Baidu; P1 8.0.0)"
	
	变量 cook名:文本 = "Cookie"
	变量 cook值:文本 = "数据太大，自己去找，比如事件结束返回的cookie"

	网络1.添加请求头(请求头名称，请求头文本)
	网络1.添加请求头(cook名,cook值)
	网络1.发送数据(网址,数据)
	//或者
	网络1.发送数据(网址,数据,cook值)
	//有的需要提前发cookie，有的需要这种跟数据一块发送。

//子结束
//结束
【文件操作常用】



//子结束
//结束
【对话框常用】



//子结束
//结束
【实用方法案例】
[打字机效果]
变量 索引:整数 = 0
 方法 打字机(组件:文本框,数据:文本)
  变量 时钟1:时钟
  时钟1.时钟周期 = 100
  事件 时钟1:周期事件()
   组件.内容 = 数据.取文本左边(索引)
   自增(索引)
   如果 索引 == 数据.长度
    时钟1.时钟周期 = 0
   结束 如果
  结束 事件
 结束 方法
 
 //子结束
//结束
[返回两次退出]
    变量 上次返回:长整数 = 0
    @虚拟方法
    方法 返回键被按下()
        如果 (取当前时间戳() - 上次返回) < 2000
         关闭程序()
        否则
          弹出提示("再按一次退出！")
          上次返回 = 取当前时间戳()
        结束 如果
    结束 方法
    
    //2000就是两秒，代表两秒内连按两次退出。
    //该方法只在窗口类里生效。
    
//子结束
//结束
[输入框调试输出]

    方法 内容输出(内容:文本)
        变量 输入框1:输入对话框
        输入框1.内容 = 内容
        输入框1.显示()
    结束 方法
    
    //常用于调试输出部分需要复制的文本
//子结束
//结束
[输入法扰乱布局]
    code getWindow().setSoftInputMode(模式值);
    //将上面的代码，放入事件里，输入法使用前使用。
    /*
    可选模式值：

0 系统默认，由系统选择显示方式

2 当用户进入时，默认隐藏输入法

4 当用户进入时，默认显示输入法

16 输入法弹出时，调整空白区域来显示输入法。即使调整空白区域，输入法还是有可能遮挡一些有内容区域，这时用户就只有退出输入法才能看到这些被遮挡区域并进行交互。

18 与16相同，但是当用户进入时，默认隐藏输入法

20 与16相同，但是当用户进入时，默认显示输入法

32 输入法弹出时，顶起当前布局（更改布局高度，同时整个布局上移）

34 与32相同，但是当用户进入时，默认隐藏输入法

36 与32相同，但是当用户进入时，默认显示输入法

48 当输入法弹出时，什么也不做，直接让输入法覆盖界面

50 与48相同，但是当用户进入时，默认隐藏输入法

52 与48相同，但是当用户进入时，默认显示输入法

//子结束
//结束

[列表框瞬间滚动到指定位置]
    code #列表框1.getView().setSelection(0);
    //列表框1替换为你的列表框名，注意#号，结尾0就是滚动到0。
    
//子结束
//结束
[QQ加群修复版]
方法 自定义加群(窗口:安卓窗口,群号:文本):逻辑型
  @code
  try {
   #<@启动信息> intent = new #<@启动信息>("android.intent.action.VIEW", 
    android.net.Uri.parse("mqqapi://card/show_pslcard?src_type=internal&version=1&uin=" + #群号 + "&card_type=group&source=qrcode"));
   #窗口.startActivity(intent);
   return true;
  } catch (Exception e) {
   return false;
  }
  @end
 结束 方法

//调用这个方法，启动窗口传入窗口，窗口类就是本对象，组件容器里就是取安卓窗口()

//子结束
//结束
[强制横屏免切换]
@附加清单.组件属性([[android:screenOrientation="landscape"]])

//附加在窗口类前，用于解决横屏切换窗口先竖屏再横屏
//每个横屏都需要，并且，删除屏幕方向，不要自己设置方向

//子结束
//结束
[列表框点击多个组件事件]
    
    事件 自定义列表框1:加载布局(索引 : 整数,项目布局 : 组件容器) : 组件容器
    变量 布局:界面布局?
    如果 布局 == 空
        布局 = 创建 界面布局
        项目布局 = 布局
      否则
        项目布局 = 布局
    结束 如果
    
    布局.按钮1.内容 = "我是按钮1"
    布局.按钮2.内容 = "我是按钮2"
    布局.按钮3.内容 = "我是按钮3"
    
    事件 布局.按钮1:被单击()
        弹出提示(索引)
    结束 事件
    
    事件 布局.按钮2:被单击()
        弹出提示("我是 按钮" + 索引.到文本())
    结束 事件
    
    事件 布局.按钮3:被单击()
        弹出提示("成功！")
    结束 事件
    
    结束 事件

类 界面布局:组件容器
	@布局配置([[根布局=真,宽度=-1,高度=-1]])
	变量 线性布局1 : 线性布局
	@布局配置([[父布局=线性布局1]])
	变量 按钮1 : 按钮
	@布局配置([[父布局=线性布局1]])
	变量 按钮2 : 按钮
	@布局配置([[父布局=线性布局1]])
	变量 按钮3 : 按钮
	
	//创建了3个按钮做列表测试。
结束 类

//子结束
//结束
【类的介绍】
[类]
类是一种数据结构，与java类释义相同，但是关键词不一样。
比如
    java创建一个类
    
    public class zdyl{
        //这里执行类代码
    }
    这是创建了一个名为zdy的公开类，在{}之间执行代码，在结绳中。
举例
    类 zdy
        //这里执行类代码
    结束 类
    与java不同的是，结绳支持鼓励中文命名，这里的zdy是类名，也可以用中文。详情见命名规则，
这里用结绳创建了一个类，

    在Java中，继承类的用法是，比如，继承view
    public class zdy extends View{
    
    //这里执行代码
    }
    
    但是在结绳中，继承是这样的
    类 zdy:View
    
    结束 类
    这里结绳继承其实有点小问题，结绳中并没有view这个关键词，所以继承方法是正确的，但是实际没有view这个类。详情见自定义类。
    
    
//子结束
//结束
[主要类]
结绳中，最常用的类有两个，一个人窗口类，一个是组件容器类。窗口类是在结绳项目创建的时候就会自动创建的一个类。
同时，结绳的可视化布局器，也只能在窗口类和组件容器类才能使用。

现在，我们先来看窗口类，首先看一下结绳创建项目自动生成的窗口类。

类 启动窗口 : 窗口
    
    事件 启动窗口:创建完毕()
        申请所有权限()
        订阅事件()
        //这里执行窗口启动完成的代码体
    结束 事件
    
    事件 启动窗口:即将创建()
        //这里执行窗口即将创建的代码体
    结束 事件
    
    事件 启动窗口:申请权限完毕(请求码 : 整数,权限集 : 文本[],允许结果 : 整数[])
        //这里执行窗口所有权限申请完毕的代码体
    结束 事件
    
    事件 启动窗口:被停止()
    //这里执行窗口即将被找回的代码体
    结束 事件
    
    事件 启动窗口:被启动()
    //这里执行窗口被启动的代码体
    结束 事件
    
    事件 启动窗口:被恢复()
        //这里执行窗口被恢复的代码体
    结束 事件
    
    事件 启动窗口:被暂停()
        //这里执行窗口被暂停的代码体
    结束 事件
    
    事件 启动窗口:被重新启动()
        //这里执行窗口被重新启动的代码体
    结束 事件
    
    事件 启动窗口:被销毁()
        //这里执行窗口即将被销毁的代码体
    结束 事件
    
结束 类

注意，结绳在实际创建窗口类的时候，只会生成一个创建完毕事件，其他事件都是启动窗口类的类事件，但是不会自动生成。
结绳项目创建完，第一个生成的窗口就是启动窗口，等于java中的main，主入口，所有代码，都从这个类开始。

类 容器1:组件容器
    
    
    事件 容器1:创建完毕()
        订阅事件
        //组件容器并不会生成创建完毕事件和订阅事件代码，这是手动添加的。
    结束 事件
结束 类

//这里，便是组件容器类的继承创建，容器1就是类名，组件容器类一般都是自定义，常用于自定义列表框，自定义对话框，等自定义布局页面。

组件容器只有两个事件，一个创建完毕()，一个绑定数据(数据:对象)两个事件。

组件容器类，常用于存储一个界面布局，供其他组件动态添加复用。



//子结束
//结束
[自定义类]
结绳是面向对象的编程，比如我们在创建一个班级程序，班级里有很多学生，每个学生姓名性别年龄都不同，每个同学在做的事也不同，这时候，我们就需要自定义类，我们需要把数据集合起来。

示例

    类 学生类
        变量 姓名:文本
        变量 性别:文本
        变量 年龄:整数
        
        变量 散步步数:整数 = 0
        
        方法 同学散步()
            散步步数 = 散步步数 + 1
        结束 方法
    
    结束 类
    
这里，我们创建了一个自定义类，类名是学生类，这个类里，还有四个变量，分别是姓名，性别，年龄，散步步数，还有一个自定义方法，同学散步，每次执行这个方法，散步步数就会+1

现在，我们来实例化，调用这个类
    变量 同学1:学生类
    //这里，就实例化，继承创建了这个学生类
    同学1.姓名 = "张三"
    同学1.性别 = "男"
    同学1.年龄 = 18
    //这里，我们设置了这个同学1的属性
    
    调试输出(同学1.散步步数)
    //这里会输出结果0，因为我们还没有修改
    
    同学1.同学散步()
    //这里，我们就调用了同学类的方法，同学散步，这个方法没有参数。再次输出步数
    
    调试输出(同学1.散步步数)
    //这时结果就是1，我们每调用一次，就会执行一次。
    
    
    我们还可以创建一个集合，用来存储所有的学生类，集合请参考集合用法。
    变量 集合1:集合
    循环(a,0,10)
        变量 同学1:同学类
        同学1.姓名 = "数据" + a.到文本()
        //这里的到文本，是把任意数据转化为文本的命令
        同学1.性别 = "男"
        同学1.年龄 = 取随机数(10,18)
        //这里的取随机数，请参照取随机数用法
        循环(b,0,取随机数(10,20)
            //这里使用了一个嵌套循环，配合随机数，用来执行同学步数随机
            同学1.同学散步()
        结束 循环
        集合1.添加成员(同学1)
        //设置好同学类的参数，再把同学类添加进集合
    结束 循环
    
    这个两重嵌套循环，外层声明创建了自定义的同学类，并设置了基本属性，姓名，性别，年龄
    内层循环执行设定了同学类的散步步数，外层循环到结束处，结束循环前把同学类加进了集合1里
    
    这时，集合1里就有了10个同学类，并且每个同学的，姓名，年龄，散步步数，都不相同。
    当我们再需要使用的时候，就从集合里取出来使用，比如我们取出第5个同学，并输出他的属性
    
    变量 数据1:同学类 = 集合1.取成员(4)
    //集合的索引也是从0开始，因此第五个就是4
    //这里，我们创建了一个新同学类，变量名是数据1，并从集合1里取出了一个同学类对象，赋值给数据1。我们输出一下。
    
    调试输出(数据1.姓名)
    调试输出(数据1.性别)
    调试输出(数据1.年龄)
    调试输出(数据1.散步步数)
    // 如此，便输出了自定义类的每个属性

//子结束
//结束
[自定义集合模板]
    集合模板类，是结绳特有的一个类，用于将一个类封装进另一个集合类。方便存取使用。
    
    示例
    
    类 子弹精灵
        变量 横坐标:整数
        变量 纵坐标:整数
        
        
        方法 子弹飞行()
            自增(纵坐标)
        结束 方法
    结束 类
    
    类 子弹池:集合模板类<子弹精灵>
    结束 类
    //如此，创建了一个自定义类，子弹精灵，还有一个集合模板类，子弹池，注意集合模板类，不允许在类里添加任何参数。
    
    变量 子弹池1:子弹池
    循环(a,0,20)
        变量 子弹1:子弹精灵
        子弹1.横坐标 = 取随机数(100,300)
        子弹1.纵坐标 = 0
        子弹池1.添加成员(子弹1)
        
        //这里，集合模板类的方法和集合一模一样，比如，添加成员，删除成员等
    结束 循环
    
    // 这一步，我们实例化创建了一个子弹池，并且存入了20个横坐标随机的子弹。
    
    提交到新线程运行()
    循环(真)
        延时(500)
        循环(子弹池1 -> 临时子弹)
            临时子弹.子弹飞行()
            
            //如此嵌套，让每个子弹都运行一次子弹飞行
        结束 循环
    结束 循环
    结束提交到新线程()
    
    //注意，因为这里是无限循环，所以提交到了线程，不然无限循环会卡死主线程导致崩溃。
    //另外，延时也会卡主线程，因为本次在新线程，所以不会卡。
    
    //首先我们创建了一个线程，其次是无限循环，接下来每500毫秒，从子弹池1集合模板类里取出临时子弹类，
    //并执行了一次子弹飞行，如此循环，子弹即可不断飞行循环，着就是集合模板类，等于把一个类装进另外一个集合，也叫集合类。
    
    延时，线程，请参考对应示例。
    
//子结束
//结束
【常用组件】
[可视化组件共有基础属性]
    // 这里的属性，是每个可视化组件都有的基础属性。
    
    "ID"  整数类型，//每个组件都有一个id，用来分辨是哪个组件
    "宽度"  整数类型，//输入-1，就是充满整个屏幕，-2就是自动适应，单位是PX
    "高度"  整数类型，//输入-1，就是充满整个屏幕，-2就是自动适应，单位是PX
    "宽度DP"  整数类型，//DP单位，控制宽度，和宽度属性，用一个即可，可以修改，不可被读取。
    "高度DP"  整数类型，//DP单位，控制高度，和高度属性，用一个即可，可以修改，不可被读取。
    "横坐标"  小数类型，//返回一个小数坐标，起始点是组件的最左上角，等同于X轴
    "纵坐标"  小数类型，//返回一个小数坐标，起始点是组件的最左上角，等同于Y轴
    "竖坐标"  小数类型，//返回一个小数坐标，等同于Z轴
    "旋转角"  小数类型，//最小0，最大360，控制组件旋转的度数
    
    "X旋转角" 小数类型，//最小0，最大360，控制组件垂直旋转度数
    "Y旋转角" 小数类型，//最小0，最大360，控制组件水平旋转度数
    
    "内边距"  整数类型，//控制组件内部的边距，单位PX，只能修改，不可被读取。
    "上内边距" 整数类型，//控制组件上方内部的边距，单位是PX。
    
    "下内边距" 整数类型，//控制组件下方内部的边距，单位是PX。
    
    "左内边距" 整数类型，//控制组件左方内部的边距，单位是PX。
    
    "右内边距" 整数类型，//控制组件右方内部的边距，单位是PX。
    
    "上内边距DP" 整数类型，//控制组件上方内部的边距，单位是DP。可以修改，不可被读取。
    
    "下内边距DP" 整数类型，//控制组件下方内部的边距，单位是DP。可以修改，不可被读取。
    
    "左内边距DP" 整数类型，//控制组件左方内部的边距，单位是DP。可以修改，不可被读取。
    
    "右内边距DP" 整数类型，//控制组件右方内部的边距，单位是DP。可以修改，不可被读取。
    
    "内边距DP" 整数类型，//控制组件内部的边距，单位是DP。可以修改，不可被读取。
    
    "阴影"  整数类型，//控制组件边缘的阴影，默认为0，最大可设置100
    
    "透明度"  双精度类型，//控制组件的透明度，最小0.00，最大1.00。
    
    "可用"  逻辑型，//控制组件是否可以被使用，默认为真。
    
    "可视"  逻辑型，//控制组件是否能被看见和保留布局，默认为真。
    
    "可获取焦点"  逻辑型，//控制组件的焦点，有点小BUG，谨慎使用。
    
    "水波纹效果"  逻辑型，//控制组件被点击后，是否有水波纹效果，默认为假，只能修改，不可被读取。
    
    "背景颜色"  整数型，//控制组件的背景颜色，输入为十进制整数类型，如白色，就是-1。只能修改，不能被读取。
    
    "背景图片"  图片资源类型，//设置组件的背景图片，需要手动将图片导入项目后再使用，或者创建图片资源变量，再赋值给背景图片。只能修改，不能被读取。
    
    
    //以上没有标注只能修改，不可被读取的属性，均可读取。
    
    可视化组件创建方法如下。
    变量 组件1:可视化组件
    
    //这里，就创建声明实例化了一个可视化组件1，请注意，这里仅作属性演示，实际运行并不允许直接创建可视化组件。
    
    //属性使用方法
    
    组件1.ID = 10
    组件1.宽度 = -1
    组件1.高度DP = 20
    
    弹出提示(组件1.ID)
    
    这些属性，在结绳的可视化布局器里，右边属性栏可以直接使用，有特殊需求再如此按照代码设置。
    
//子结束
//结束
[对齐方式详解]
    节省提供了对齐方式的基类封装，部分可视化组件和部分可视化布局会继承该类，属性如下
    
    "居中"  对应整数17
    "垂直居中"  对应整数16
    "水平居中"  对应整数1
    "靠上对齐"  对应整数48
    "靠下对齐"  对应整数80
    "靠左对齐"  对应整数8388611
    "靠右对齐"  对应整数8388163
    
    以上属性，调用方式如下。
    
    变量 文本1:文本框
    //我们创建一个文本框组件，调整内部的文本对齐方式
    
    文本1.对齐方式 = 对齐方式.居中
    //这是第一种
    
    文本1.对齐方式 = 17
    //这是第二种，也是居中对齐
    
    这些属性，在结绳的可视化布局器里，右边属性栏可以直接使用，有特殊需求再如此按照代码设置。
//子结束
//结束
[文本框]
    继承自可视化组件，拥有可视化组件的所有属性以外，还有额外属性。
    
    "对齐方式"  继承自对齐方式类，拥有对齐方式的所有属性
    
    "内容"  文本型，用于设置文本框显示的内容。
    
    "粗体"  逻辑型，用来控制文本框字体的粗细。
    
    "字体大小"  整数型，用来控制文本框的字体大小。
    
    "字体颜色"  整数型，用来控制文本框的字体颜色，颜色为十进制整数。
    
    "显示行数"  整数型，用来控制文本框最多可以显示多少行。
    
    "单行显示"  逻辑型，为真的时候，文本框只显示一行。
    
    "省略显示"  整数型，设置文本过长时，省略显示的方式，0为省略开头，1为省略中间，2为省省略结尾
    
    

[编辑框]

[按钮]

[单选框]

[多选框]

[视频播放器]

[图片框]

[自定义列表]

[自定义宫格列表]

//子结束
//结束
【常用布局】
[自适应布局]

[线性布局]

[相对布局]

[卡片布局]

[滚动布局]

[单选框布局]

[宫格布局]

[侧滑布局]

[分页布局]

//子结束
//结束